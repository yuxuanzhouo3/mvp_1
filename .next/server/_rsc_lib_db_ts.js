/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_rsc_lib_db_ts";
exports.ids = ["_rsc_lib_db_ts"];
exports.modules = {

/***/ "?32c4":
/*!****************************!*\
  !*** bufferutil (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?66e9":
/*!********************************!*\
  !*** utf-8-validate (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "(rsc)/./lib/db.ts":
/*!*******************!*\
  !*** ./lib/db.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   db: () => (/* binding */ db),\n/* harmony export */   getDBClient: () => (/* binding */ getDBClient),\n/* harmony export */   initializeDatabase: () => (/* binding */ initializeDatabase)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var _utils_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/retry */ \"(rsc)/./lib/utils/retry.ts\");\n/* harmony import */ var _utils_circuitBreaker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/circuitBreaker */ \"(rsc)/./lib/utils/circuitBreaker.ts\");\n\n\n\nclass DBConnection {\n    static{\n        this.healthStatus = {\n            status: \"unhealthy\",\n            responseTime: 0,\n            lastCheck: new Date(),\n            errorCount: 0,\n            successCount: 0,\n            activeConnections: 0,\n            queueSize: 0\n        };\n    }\n    static{\n        this.isInitialized = false;\n    }\n    static{\n        this.connectionPool = new Map();\n    }\n    static{\n        this.lastRecycleTime = Date.now();\n    }\n    static{\n        this.RECYCLE_INTERVAL = 300000 // 5ÂàÜÈíü\n        ;\n    }\n    static{\n        this.MAX_POOL_SIZE = 10;\n    }\n    static initialize(config) {\n        if (this.isInitialized) {\n            console.warn(\"‚ö†Ô∏è  Database connection manager already initialized\");\n            return;\n        }\n        this.config = {\n            maxRetries: 3,\n            retryDelay: 1000,\n            timeout: 10000,\n            maxConnections: 20,\n            idleTimeout: 30000,\n            environment: \"development\",\n            ...config\n        };\n        // ÁéØÂ¢ÉÁâπÂÆöÈÖçÁΩÆ\n        this.applyEnvironmentConfig();\n        this.circuitBreaker = new _utils_circuitBreaker__WEBPACK_IMPORTED_MODULE_1__.CircuitBreaker({\n            failureThreshold: this.config.environment === \"production\" ? 3 : 5,\n            recoveryTimeout: this.config.environment === \"production\" ? 30000 : 60000,\n            expectedResponseTime: this.config.timeout\n        });\n        this.instance = this.createClient();\n        this.isInitialized = true;\n        this.startHealthMonitoring();\n        this.startConnectionRecycling();\n        console.log(`‚úÖ Database connection manager initialized for ${this.config.environment} environment`);\n    }\n    static applyEnvironmentConfig() {\n        switch(this.config.environment){\n            case \"production\":\n                this.config.maxRetries = 5;\n                this.config.timeout = 15000;\n                this.config.maxConnections = 50;\n                break;\n            case \"staging\":\n                this.config.maxRetries = 4;\n                this.config.timeout = 12000;\n                this.config.maxConnections = 30;\n                break;\n            case \"development\":\n            default:\n                this.config.maxRetries = 3;\n                this.config.timeout = 10000;\n                this.config.maxConnections = 20;\n                break;\n        }\n    }\n    static createClient() {\n        return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_2__.createClient)(this.config.url, this.config.serviceRoleKey, {\n            auth: {\n                autoRefreshToken: true,\n                persistSession: false\n            },\n            global: {\n                headers: {\n                    \"X-Client-Info\": `personalink-db-manager-${this.config.environment}`\n                },\n                fetch: this.customFetchWithRetry.bind(this)\n            }\n        });\n    }\n    static getInstance() {\n        if (!this.isInitialized) {\n            throw new Error(\"Database connection manager not initialized. Call initialize() first.\");\n        }\n        return this.instance;\n    }\n    static get getInitializationStatus() {\n        return this.isInitialized;\n    }\n    static getConnectionFromPool(key) {\n        if (this.connectionPool.has(key)) {\n            return this.connectionPool.get(key);\n        }\n        if (this.connectionPool.size >= this.MAX_POOL_SIZE) {\n            // ÂõûÊî∂ÊúÄÊóßÁöÑËøûÊé•\n            const oldestKey = this.connectionPool.keys().next().value;\n            if (oldestKey) {\n                this.connectionPool.delete(oldestKey);\n            }\n        }\n        const connection = this.createClient();\n        this.connectionPool.set(key, connection);\n        return connection;\n    }\n    static startConnectionRecycling() {\n        setInterval(()=>{\n            this.recycleConnections();\n        }, this.RECYCLE_INTERVAL);\n    }\n    static recycleConnections() {\n        const now = Date.now();\n        const connectionsToRemove = [];\n        this.connectionPool.forEach((connection, key)=>{\n            // ËøôÈáåÂèØ‰ª•Ê∑ªÂä†ËøûÊé•ÂÅ•Â∫∑Ê£ÄÊü•ÈÄªËæë\n            // ÊöÇÊó∂ÁÆÄÂçïÂú∞ÂõûÊî∂ÊâÄÊúâËøûÊé•\n            connectionsToRemove.push(key);\n        });\n        connectionsToRemove.forEach((key)=>{\n            this.connectionPool.delete(key);\n        });\n        if (connectionsToRemove.length > 0) {\n            console.log(`üîÑ Recycled ${connectionsToRemove.length} database connections`);\n        }\n        this.lastRecycleTime = now;\n    }\n    static async customFetchWithRetry(input, init) {\n        const startTime = Date.now();\n        return this.circuitBreaker.execute(async ()=>{\n            try {\n                this.healthStatus.activeConnections++;\n                this.healthStatus.queueSize++;\n                const response = await fetch(input, {\n                    ...init,\n                    signal: AbortSignal.timeout(this.config.timeout || 10000)\n                });\n                const responseTime = Date.now() - startTime;\n                this.updateHealth(true, responseTime);\n                return response;\n            } catch (error) {\n                const responseTime = Date.now() - startTime;\n                this.updateHealth(false, responseTime);\n                throw error;\n            } finally{\n                this.healthStatus.activeConnections = Math.max(0, this.healthStatus.activeConnections - 1);\n                this.healthStatus.queueSize = Math.max(0, this.healthStatus.queueSize - 1);\n            }\n        });\n    }\n    static updateHealth(success, responseTime) {\n        this.healthStatus.responseTime = responseTime;\n        this.healthStatus.lastCheck = new Date();\n        if (success) {\n            this.healthStatus.successCount++;\n            this.healthStatus.errorCount = Math.max(0, this.healthStatus.errorCount - 1);\n        } else {\n            this.healthStatus.errorCount++;\n        }\n        // Êõ¥Êñ∞ÂÅ•Â∫∑Áä∂ÊÄÅ\n        const errorRate = this.healthStatus.errorCount / (this.healthStatus.successCount + this.healthStatus.errorCount);\n        if (errorRate === 0) {\n            this.healthStatus.status = \"healthy\";\n        } else if (errorRate < 0.1) {\n            this.healthStatus.status = \"degraded\";\n        } else {\n            this.healthStatus.status = \"unhealthy\";\n        }\n    }\n    static startHealthMonitoring() {\n        this.healthCheckInterval = setInterval(async ()=>{\n            await this.performHealthCheck();\n        }, 30000); // ÊØè30ÁßíÊ£ÄÊü•‰∏ÄÊ¨°\n    }\n    static async performHealthCheck() {\n        try {\n            const startTime = Date.now();\n            const { data, error } = await this.instance.from(\"profiles\").select(\"count\").limit(1);\n            const responseTime = Date.now() - startTime;\n            if (error) {\n                this.updateHealth(false, responseTime);\n                console.warn(\"‚ö†Ô∏è  Health check failed:\", error.message);\n            } else {\n                this.updateHealth(true, responseTime);\n            }\n        } catch (error) {\n            this.updateHealth(false, 0);\n            console.error(\"‚ùå Health check error:\", error);\n        }\n    }\n    static getHealthStatus() {\n        return {\n            ...this.healthStatus\n        };\n    }\n    static async executeWithRetry(operation, context = \"database operation\") {\n        if (!this.isInitialized) {\n            throw new Error(\"Database connection manager not initialized\");\n        }\n        return this.circuitBreaker.execute(async ()=>{\n            let lastError = null;\n            for(let attempt = 1; attempt <= this.config.maxRetries; attempt++){\n                try {\n                    const result = await operation();\n                    this.updateHealth(true, 0);\n                    return result;\n                } catch (error) {\n                    lastError = error;\n                    this.updateHealth(false, 0);\n                    console.error(`‚ùå ${context} failed (attempt ${attempt}/${this.config.maxRetries}):`, error);\n                    if (attempt < this.config.maxRetries) {\n                        const delay = (0,_utils_retry__WEBPACK_IMPORTED_MODULE_0__.exponentialBackoff)(attempt, this.config.retryDelay);\n                        console.log(`‚è≥ Retrying in ${delay}ms...`);\n                        await this.sleep(delay);\n                    }\n                }\n            }\n            throw new Error(`${context} failed after ${this.config.maxRetries} attempts: ${lastError?.message}`);\n        });\n    }\n    static sleep(ms) {\n        return new Promise((resolve)=>setTimeout(resolve, ms));\n    }\n    static async resetConnection() {\n        this.isInitialized = false;\n        this.healthStatus = {\n            status: \"unhealthy\",\n            responseTime: 0,\n            lastCheck: new Date(),\n            errorCount: 0,\n            successCount: 0,\n            activeConnections: 0,\n            queueSize: 0\n        };\n        // Ê∏ÖÁêÜËøûÊé•Ê±†\n        this.connectionPool.clear();\n        if (this.healthCheckInterval) {\n            clearInterval(this.healthCheckInterval);\n        }\n        await this.initialize(this.config);\n    }\n    static getStats() {\n        return {\n            health: this.healthStatus,\n            config: this.config,\n            isInitialized: this.isInitialized,\n            circuitBreaker: this.circuitBreaker?.getStatus() || {\n                state: \"unknown\",\n                failureCount: 0\n            },\n            connectionPool: {\n                size: this.connectionPool.size,\n                maxSize: this.MAX_POOL_SIZE,\n                lastRecycle: this.lastRecycleTime\n            }\n        };\n    }\n}\n// ÂØºÂá∫Âçï‰æãÂÆû‰æã\nconst db = DBConnection;\n// ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ìËøûÊé•\nfunction initializeDatabase() {\n    const environment = \"development\" || 0;\n    db.initialize({\n        url: \"https://bamratexknmqvdbalzen.supabase.co\",\n        anonKey: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJhbXJhdGV4a25tcXZkYmFsemVuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI1MTM4NzEsImV4cCI6MjA2ODA4OTg3MX0.yYa98ioJLLouUgHWITGb7U_VjNCTUuM-5NcraM7f3zA\",\n        serviceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY,\n        environment,\n        maxRetries: 3,\n        retryDelay: 1000,\n        timeout: 10000,\n        maxConnections: 20,\n        idleTimeout: 30000\n    });\n}\n// Ëé∑ÂèñÊï∞ÊçÆÂ∫ìÂÆ¢Êà∑Á´Ø\nfunction getDBClient() {\n    return db.getInstance();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxjQUFjLEVBQUU2RSxlQUFlO2dCQUFFQyxPQUFPO2dCQUFXQyxjQUFjO1lBQUU7WUFDeEZoRyxnQkFBZ0I7Z0JBQ2QwQyxNQUFNLElBQUksQ0FBQzFDLGNBQWMsQ0FBQzBDLElBQUk7Z0JBQzlCdUQsU0FBUyxJQUFJLENBQUM1RixhQUFhO2dCQUMzQjZGLGFBQWEsSUFBSSxDQUFDaEcsZUFBZTtZQUNuQztRQUNGO0lBQ0Y7QUFDRjtBQUVBLFNBQVM7QUFDRixNQUFNaUcsS0FBSzlHLGFBQWE7QUFFL0IsV0FBVztBQUNKLFNBQVMrRztJQUNkLE1BQU1yRixjQUFjc0YsaUJBQW9FO0lBRXhGRixHQUFHN0YsVUFBVSxDQUFDO1FBQ1ptQixLQUFLNEUsMENBQW9DO1FBQ3pDRyxTQUFTSCxrTkFBeUM7UUFDbEQzRSxnQkFBZ0IyRSxRQUFRQyxHQUFHLENBQUNJLHlCQUF5QjtRQUNyRDNGO1FBQ0FMLFlBQVk7UUFDWkMsWUFBWTtRQUNaQyxTQUFTO1FBQ1RDLGdCQUFnQjtRQUNoQkMsYUFBYTtJQUNmO0FBQ0Y7QUFFQSxXQUFXO0FBQ0osU0FBUzZGO0lBQ2QsT0FBT1IsR0FBR2hFLFdBQVc7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbGluay8uL2xpYi9kYi50cz8xZGYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCwgU3VwYWJhc2VDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgZXhwb25lbnRpYWxCYWNrb2ZmIH0gZnJvbSAnLi91dGlscy9yZXRyeSc7XG5pbXBvcnQgeyBDaXJjdWl0QnJlYWtlciB9IGZyb20gJy4vdXRpbHMvY2lyY3VpdEJyZWFrZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIERCSGVhbHRoU3RhdHVzIHtcbiAgc3RhdHVzOiAnaGVhbHRoeScgfCAnZGVncmFkZWQnIHwgJ3VuaGVhbHRoeSc7XG4gIHJlc3BvbnNlVGltZTogbnVtYmVyO1xuICBsYXN0Q2hlY2s6IERhdGU7XG4gIGVycm9yQ291bnQ6IG51bWJlcjtcbiAgc3VjY2Vzc0NvdW50OiBudW1iZXI7XG4gIGFjdGl2ZUNvbm5lY3Rpb25zOiBudW1iZXI7XG4gIHF1ZXVlU2l6ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbm5lY3Rpb25Db25maWcge1xuICB1cmw6IHN0cmluZztcbiAgYW5vbktleTogc3RyaW5nO1xuICBzZXJ2aWNlUm9sZUtleTogc3RyaW5nO1xuICBtYXhSZXRyaWVzPzogbnVtYmVyO1xuICByZXRyeURlbGF5PzogbnVtYmVyO1xuICB0aW1lb3V0PzogbnVtYmVyO1xuICBtYXhDb25uZWN0aW9ucz86IG51bWJlcjtcbiAgaWRsZVRpbWVvdXQ/OiBudW1iZXI7XG4gIGVudmlyb25tZW50PzogJ2RldmVsb3BtZW50JyB8ICdzdGFnaW5nJyB8ICdwcm9kdWN0aW9uJztcbn1cblxuY2xhc3MgREJDb25uZWN0aW9uIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFN1cGFiYXNlQ2xpZW50O1xuICBwcml2YXRlIHN0YXRpYyBoZWFsdGhTdGF0dXM6IERCSGVhbHRoU3RhdHVzID0ge1xuICAgIHN0YXR1czogJ3VuaGVhbHRoeScsXG4gICAgcmVzcG9uc2VUaW1lOiAwLFxuICAgIGxhc3RDaGVjazogbmV3IERhdGUoKSxcbiAgICBlcnJvckNvdW50OiAwLFxuICAgIHN1Y2Nlc3NDb3VudDogMCxcbiAgICBhY3RpdmVDb25uZWN0aW9uczogMCxcbiAgICBxdWV1ZVNpemU6IDBcbiAgfTtcbiAgXG4gIHByaXZhdGUgc3RhdGljIGNpcmN1aXRCcmVha2VyOiBDaXJjdWl0QnJlYWtlcjtcbiAgcHJpdmF0ZSBzdGF0aWMgY29uZmlnOiBDb25uZWN0aW9uQ29uZmlnO1xuICBwcml2YXRlIHN0YXRpYyBpc0luaXRpYWxpemVkID0gZmFsc2U7XG4gIHByaXZhdGUgc3RhdGljIGhlYWx0aENoZWNrSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0O1xuICBwcml2YXRlIHN0YXRpYyBjb25uZWN0aW9uUG9vbDogTWFwPHN0cmluZywgU3VwYWJhc2VDbGllbnQ+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHN0YXRpYyBsYXN0UmVjeWNsZVRpbWUgPSBEYXRlLm5vdygpO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBSRUNZQ0xFX0lOVEVSVkFMID0gMzAwMDAwOyAvLyA15YiG6ZKfXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE1BWF9QT09MX1NJWkUgPSAxMDtcblxuICBzdGF0aWMgaW5pdGlhbGl6ZShjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyAgRGF0YWJhc2UgY29ubmVjdGlvbiBtYW5hZ2VyIGFscmVhZHkgaW5pdGlhbGl6ZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICByZXRyeURlbGF5OiAxMDAwLFxuICAgICAgdGltZW91dDogMTAwMDAsXG4gICAgICBtYXhDb25uZWN0aW9uczogMjAsXG4gICAgICBpZGxlVGltZW91dDogMzAwMDAsXG4gICAgICBlbnZpcm9ubWVudDogJ2RldmVsb3BtZW50JyxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG5cbiAgICAvLyDnjq/looPnibnlrprphY3nva5cbiAgICB0aGlzLmFwcGx5RW52aXJvbm1lbnRDb25maWcoKTtcblxuICAgIHRoaXMuY2lyY3VpdEJyZWFrZXIgPSBuZXcgQ2lyY3VpdEJyZWFrZXIoe1xuICAgICAgZmFpbHVyZVRocmVzaG9sZDogdGhpcy5jb25maWcuZW52aXJvbm1lbnQgPT09ICdwcm9kdWN0aW9uJyA/IDMgOiA1LFxuICAgICAgcmVjb3ZlcnlUaW1lb3V0OiB0aGlzLmNvbmZpZy5lbnZpcm9ubWVudCA9PT0gJ3Byb2R1Y3Rpb24nID8gMzAwMDAgOiA2MDAwMCxcbiAgICAgIGV4cGVjdGVkUmVzcG9uc2VUaW1lOiB0aGlzLmNvbmZpZy50aW1lb3V0IVxuICAgIH0pO1xuXG4gICAgdGhpcy5pbnN0YW5jZSA9IHRoaXMuY3JlYXRlQ2xpZW50KCk7XG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXJ0SGVhbHRoTW9uaXRvcmluZygpO1xuICAgIHRoaXMuc3RhcnRDb25uZWN0aW9uUmVjeWNsaW5nKCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYOKchSBEYXRhYmFzZSBjb25uZWN0aW9uIG1hbmFnZXIgaW5pdGlhbGl6ZWQgZm9yICR7dGhpcy5jb25maWcuZW52aXJvbm1lbnR9IGVudmlyb25tZW50YCk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBhcHBseUVudmlyb25tZW50Q29uZmlnKCk6IHZvaWQge1xuICAgIHN3aXRjaCAodGhpcy5jb25maWcuZW52aXJvbm1lbnQpIHtcbiAgICAgIGNhc2UgJ3Byb2R1Y3Rpb24nOlxuICAgICAgICB0aGlzLmNvbmZpZy5tYXhSZXRyaWVzID0gNTtcbiAgICAgICAgdGhpcy5jb25maWcudGltZW91dCA9IDE1MDAwO1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXhDb25uZWN0aW9ucyA9IDUwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0YWdpbmcnOlxuICAgICAgICB0aGlzLmNvbmZpZy5tYXhSZXRyaWVzID0gNDtcbiAgICAgICAgdGhpcy5jb25maWcudGltZW91dCA9IDEyMDAwO1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXhDb25uZWN0aW9ucyA9IDMwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RldmVsb3BtZW50JzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuY29uZmlnLm1heFJldHJpZXMgPSAzO1xuICAgICAgICB0aGlzLmNvbmZpZy50aW1lb3V0ID0gMTAwMDA7XG4gICAgICAgIHRoaXMuY29uZmlnLm1heENvbm5lY3Rpb25zID0gMjA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGNyZWF0ZUNsaWVudCgpOiBTdXBhYmFzZUNsaWVudCB7XG4gICAgcmV0dXJuIGNyZWF0ZUNsaWVudCh0aGlzLmNvbmZpZy51cmwsIHRoaXMuY29uZmlnLnNlcnZpY2VSb2xlS2V5LCB7XG4gICAgICBhdXRoOiB7XG4gICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gICAgICAgIHBlcnNpc3RTZXNzaW9uOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ1gtQ2xpZW50LUluZm8nOiBgcGVyc29uYWxpbmstZGItbWFuYWdlci0ke3RoaXMuY29uZmlnLmVudmlyb25tZW50fWBcbiAgICAgICAgfSxcbiAgICAgICAgZmV0Y2g6IHRoaXMuY3VzdG9tRmV0Y2hXaXRoUmV0cnkuYmluZCh0aGlzKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IFN1cGFiYXNlQ2xpZW50IHtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIG1hbmFnZXIgbm90IGluaXRpYWxpemVkLiBDYWxsIGluaXRpYWxpemUoKSBmaXJzdC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGdldEluaXRpYWxpemF0aW9uU3RhdHVzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzSW5pdGlhbGl6ZWQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0Q29ubmVjdGlvbkZyb21Qb29sKGtleTogc3RyaW5nKTogU3VwYWJhc2VDbGllbnQge1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25Qb29sLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uUG9vbC5nZXQoa2V5KSE7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29ubmVjdGlvblBvb2wuc2l6ZSA+PSB0aGlzLk1BWF9QT09MX1NJWkUpIHtcbiAgICAgIC8vIOWbnuaUtuacgOaXp+eahOi/nuaOpVxuICAgICAgY29uc3Qgb2xkZXN0S2V5ID0gdGhpcy5jb25uZWN0aW9uUG9vbC5rZXlzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgaWYgKG9sZGVzdEtleSkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sLmRlbGV0ZShvbGRlc3RLZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmNyZWF0ZUNsaWVudCgpO1xuICAgIHRoaXMuY29ubmVjdGlvblBvb2wuc2V0KGtleSwgY29ubmVjdGlvbik7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBzdGFydENvbm5lY3Rpb25SZWN5Y2xpbmcoKTogdm9pZCB7XG4gICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5yZWN5Y2xlQ29ubmVjdGlvbnMoKTtcbiAgICB9LCB0aGlzLlJFQ1lDTEVfSU5URVJWQUwpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcmVjeWNsZUNvbm5lY3Rpb25zKCk6IHZvaWQge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgY29ubmVjdGlvbnNUb1JlbW92ZTogc3RyaW5nW10gPSBbXTtcblxuICAgIHRoaXMuY29ubmVjdGlvblBvb2wuZm9yRWFjaCgoY29ubmVjdGlvbiwga2V5KSA9PiB7XG4gICAgICAvLyDov5nph4zlj6/ku6Xmt7vliqDov57mjqXlgaXlurfmo4Dmn6XpgLvovpFcbiAgICAgIC8vIOaaguaXtueugOWNleWcsOWbnuaUtuaJgOaciei/nuaOpVxuICAgICAgY29ubmVjdGlvbnNUb1JlbW92ZS5wdXNoKGtleSk7XG4gICAgfSk7XG5cbiAgICBjb25uZWN0aW9uc1RvUmVtb3ZlLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wuZGVsZXRlKGtleSk7XG4gICAgfSk7XG5cbiAgICBpZiAoY29ubmVjdGlvbnNUb1JlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+UhCBSZWN5Y2xlZCAke2Nvbm5lY3Rpb25zVG9SZW1vdmUubGVuZ3RofSBkYXRhYmFzZSBjb25uZWN0aW9uc2ApO1xuICAgIH1cblxuICAgIHRoaXMubGFzdFJlY3ljbGVUaW1lID0gbm93O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgY3VzdG9tRmV0Y2hXaXRoUmV0cnkoXG4gICAgaW5wdXQ6IFJlcXVlc3RJbmZvIHwgVVJMLCBcbiAgICBpbml0PzogUmVxdWVzdEluaXRcbiAgKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuY2lyY3VpdEJyZWFrZXIuZXhlY3V0ZShhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmhlYWx0aFN0YXR1cy5hY3RpdmVDb25uZWN0aW9ucysrO1xuICAgICAgICB0aGlzLmhlYWx0aFN0YXR1cy5xdWV1ZVNpemUrKztcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goaW5wdXQsIHtcbiAgICAgICAgICAuLi5pbml0LFxuICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLmNvbmZpZy50aW1lb3V0IHx8IDEwMDAwKVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgIHRoaXMudXBkYXRlSGVhbHRoKHRydWUsIHJlc3BvbnNlVGltZSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLnVwZGF0ZUhlYWx0aChmYWxzZSwgcmVzcG9uc2VUaW1lKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmhlYWx0aFN0YXR1cy5hY3RpdmVDb25uZWN0aW9ucyA9IE1hdGgubWF4KDAsIHRoaXMuaGVhbHRoU3RhdHVzLmFjdGl2ZUNvbm5lY3Rpb25zIC0gMSk7XG4gICAgICAgIHRoaXMuaGVhbHRoU3RhdHVzLnF1ZXVlU2l6ZSA9IE1hdGgubWF4KDAsIHRoaXMuaGVhbHRoU3RhdHVzLnF1ZXVlU2l6ZSAtIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgdXBkYXRlSGVhbHRoKHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3BvbnNlVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5oZWFsdGhTdGF0dXMucmVzcG9uc2VUaW1lID0gcmVzcG9uc2VUaW1lO1xuICAgIHRoaXMuaGVhbHRoU3RhdHVzLmxhc3RDaGVjayA9IG5ldyBEYXRlKCk7XG5cbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgdGhpcy5oZWFsdGhTdGF0dXMuc3VjY2Vzc0NvdW50Kys7XG4gICAgICB0aGlzLmhlYWx0aFN0YXR1cy5lcnJvckNvdW50ID0gTWF0aC5tYXgoMCwgdGhpcy5oZWFsdGhTdGF0dXMuZXJyb3JDb3VudCAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWx0aFN0YXR1cy5lcnJvckNvdW50Kys7XG4gICAgfVxuXG4gICAgLy8g5pu05paw5YGl5bq354q25oCBXG4gICAgY29uc3QgZXJyb3JSYXRlID0gdGhpcy5oZWFsdGhTdGF0dXMuZXJyb3JDb3VudCAvICh0aGlzLmhlYWx0aFN0YXR1cy5zdWNjZXNzQ291bnQgKyB0aGlzLmhlYWx0aFN0YXR1cy5lcnJvckNvdW50KTtcbiAgICBcbiAgICBpZiAoZXJyb3JSYXRlID09PSAwKSB7XG4gICAgICB0aGlzLmhlYWx0aFN0YXR1cy5zdGF0dXMgPSAnaGVhbHRoeSc7XG4gICAgfSBlbHNlIGlmIChlcnJvclJhdGUgPCAwLjEpIHtcbiAgICAgIHRoaXMuaGVhbHRoU3RhdHVzLnN0YXR1cyA9ICdkZWdyYWRlZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhbHRoU3RhdHVzLnN0YXR1cyA9ICd1bmhlYWx0aHknO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIHN0YXJ0SGVhbHRoTW9uaXRvcmluZygpOiB2b2lkIHtcbiAgICB0aGlzLmhlYWx0aENoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLnBlcmZvcm1IZWFsdGhDaGVjaygpO1xuICAgIH0sIDMwMDAwKTsgLy8g5q+PMzDnp5Lmo4Dmn6XkuIDmrKFcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGFzeW5jIHBlcmZvcm1IZWFsdGhDaGVjaygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuaW5zdGFuY2VcbiAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgLnNlbGVjdCgnY291bnQnKVxuICAgICAgICAubGltaXQoMSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aGlzLnVwZGF0ZUhlYWx0aChmYWxzZSwgcmVzcG9uc2VUaW1lKTtcbiAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gIEhlYWx0aCBjaGVjayBmYWlsZWQ6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVwZGF0ZUhlYWx0aCh0cnVlLCByZXNwb25zZVRpbWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhlYWx0aChmYWxzZSwgMCk7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgSGVhbHRoIGNoZWNrIGVycm9yOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0SGVhbHRoU3RhdHVzKCk6IERCSGVhbHRoU3RhdHVzIHtcbiAgICByZXR1cm4geyAuLi50aGlzLmhlYWx0aFN0YXR1cyB9O1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIGV4ZWN1dGVXaXRoUmV0cnk8VD4oXG4gICAgb3BlcmF0aW9uOiAoKSA9PiBQcm9taXNlPFQ+LFxuICAgIGNvbnRleHQ6IHN0cmluZyA9ICdkYXRhYmFzZSBvcGVyYXRpb24nXG4gICk6IFByb21pc2U8VD4ge1xuICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gbWFuYWdlciBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaXJjdWl0QnJlYWtlci5leGVjdXRlKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBsYXN0RXJyb3I6IEVycm9yIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IHRoaXMuY29uZmlnLm1heFJldHJpZXMhOyBhdHRlbXB0KyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvcGVyYXRpb24oKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUhlYWx0aCh0cnVlLCAwKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxhc3RFcnJvciA9IGVycm9yIGFzIEVycm9yO1xuICAgICAgICAgIHRoaXMudXBkYXRlSGVhbHRoKGZhbHNlLCAwKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgJHtjb250ZXh0fSBmYWlsZWQgKGF0dGVtcHQgJHthdHRlbXB0fS8ke3RoaXMuY29uZmlnLm1heFJldHJpZXN9KTpgLCBlcnJvcik7XG5cbiAgICAgICAgICBpZiAoYXR0ZW1wdCA8IHRoaXMuY29uZmlnLm1heFJldHJpZXMhKSB7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IGV4cG9uZW50aWFsQmFja29mZihhdHRlbXB0LCB0aGlzLmNvbmZpZy5yZXRyeURlbGF5ISk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4o+zIFJldHJ5aW5nIGluICR7ZGVsYXl9bXMuLi5gKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2xlZXAoZGVsYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH0gZmFpbGVkIGFmdGVyICR7dGhpcy5jb25maWcubWF4UmV0cmllc30gYXR0ZW1wdHM6ICR7bGFzdEVycm9yPy5tZXNzYWdlfWApO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgc2xlZXAobXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyByZXNldENvbm5lY3Rpb24oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5oZWFsdGhTdGF0dXMgPSB7XG4gICAgICBzdGF0dXM6ICd1bmhlYWx0aHknLFxuICAgICAgcmVzcG9uc2VUaW1lOiAwLFxuICAgICAgbGFzdENoZWNrOiBuZXcgRGF0ZSgpLFxuICAgICAgZXJyb3JDb3VudDogMCxcbiAgICAgIHN1Y2Nlc3NDb3VudDogMCxcbiAgICAgIGFjdGl2ZUNvbm5lY3Rpb25zOiAwLFxuICAgICAgcXVldWVTaXplOiAwXG4gICAgfTtcbiAgICBcbiAgICAvLyDmuIXnkIbov57mjqXmsaBcbiAgICB0aGlzLmNvbm5lY3Rpb25Qb29sLmNsZWFyKCk7XG4gICAgXG4gICAgaWYgKHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYWx0aENoZWNrSW50ZXJ2YWwpO1xuICAgIH1cbiAgICBcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUodGhpcy5jb25maWcpO1xuICB9XG5cbiAgc3RhdGljIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBoZWFsdGg6IHRoaXMuaGVhbHRoU3RhdHVzLFxuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGlzSW5pdGlhbGl6ZWQ6IHRoaXMuaXNJbml0aWFsaXplZCxcbiAgICAgIGNpcmN1aXRCcmVha2VyOiB0aGlzLmNpcmN1aXRCcmVha2VyPy5nZXRTdGF0dXMoKSB8fCB7IHN0YXRlOiAndW5rbm93bicsIGZhaWx1cmVDb3VudDogMCB9LFxuICAgICAgY29ubmVjdGlvblBvb2w6IHtcbiAgICAgICAgc2l6ZTogdGhpcy5jb25uZWN0aW9uUG9vbC5zaXplLFxuICAgICAgICBtYXhTaXplOiB0aGlzLk1BWF9QT09MX1NJWkUsXG4gICAgICAgIGxhc3RSZWN5Y2xlOiB0aGlzLmxhc3RSZWN5Y2xlVGltZVxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuLy8g5a+85Ye65Y2V5L6L5a6e5L6LXG5leHBvcnQgY29uc3QgZGIgPSBEQkNvbm5lY3Rpb247XG5cbi8vIOWIneWni+WMluaVsOaNruW6k+i/nuaOpVxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVEYXRhYmFzZSgpOiB2b2lkIHtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViBhcyAnZGV2ZWxvcG1lbnQnIHwgJ3N0YWdpbmcnIHwgJ3Byb2R1Y3Rpb24nIHx8ICdkZXZlbG9wbWVudCc7XG4gIFxuICBkYi5pbml0aWFsaXplKHtcbiAgICB1cmw6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCEsXG4gICAgYW5vbktleTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkhLFxuICAgIHNlcnZpY2VSb2xlS2V5OiBwcm9jZXNzLmVudi5TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZISxcbiAgICBlbnZpcm9ubWVudCxcbiAgICBtYXhSZXRyaWVzOiAzLFxuICAgIHJldHJ5RGVsYXk6IDEwMDAsXG4gICAgdGltZW91dDogMTAwMDAsXG4gICAgbWF4Q29ubmVjdGlvbnM6IDIwLFxuICAgIGlkbGVUaW1lb3V0OiAzMDAwMFxuICB9KTtcbn1cblxuLy8g6I635Y+W5pWw5o2u5bqT5a6i5oi356uvXG5leHBvcnQgZnVuY3Rpb24gZ2V0REJDbGllbnQoKTogU3VwYWJhc2VDbGllbnQge1xuICByZXR1cm4gZGIuZ2V0SW5zdGFuY2UoKTtcbn0gIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsImV4cG9uZW50aWFsQmFja29mZiIsIkNpcmN1aXRCcmVha2VyIiwiREJDb25uZWN0aW9uIiwiaGVhbHRoU3RhdHVzIiwic3RhdHVzIiwicmVzcG9uc2VUaW1lIiwibGFzdENoZWNrIiwiRGF0ZSIsImVycm9yQ291bnQiLCJzdWNjZXNzQ291bnQiLCJhY3RpdmVDb25uZWN0aW9ucyIsInF1ZXVlU2l6ZSIsImlzSW5pdGlhbGl6ZWQiLCJjb25uZWN0aW9uUG9vbCIsIk1hcCIsImxhc3RSZWN5Y2xlVGltZSIsIm5vdyIsIlJFQ1lDTEVfSU5URVJWQUwiLCJNQVhfUE9PTF9TSVpFIiwiaW5pdGlhbGl6ZSIsImNvbmZpZyIsImNvbnNvbGUiLCJ3YXJuIiwibWF4UmV0cmllcyIsInJldHJ5RGVsYXkiLCJ0aW1lb3V0IiwibWF4Q29ubmVjdGlvbnMiLCJpZGxlVGltZW91dCIsImVudmlyb25tZW50IiwiYXBwbHlFbnZpcm9ubWVudENvbmZpZyIsImNpcmN1aXRCcmVha2VyIiwiZmFpbHVyZVRocmVzaG9sZCIsInJlY292ZXJ5VGltZW91dCIsImV4cGVjdGVkUmVzcG9uc2VUaW1lIiwiaW5zdGFuY2UiLCJzdGFydEhlYWx0aE1vbml0b3JpbmciLCJzdGFydENvbm5lY3Rpb25SZWN5Y2xpbmciLCJsb2ciLCJ1cmwiLCJzZXJ2aWNlUm9sZUtleSIsImF1dGgiLCJhdXRvUmVmcmVzaFRva2VuIiwicGVyc2lzdFNlc3Npb24iLCJnbG9iYWwiLCJoZWFkZXJzIiwiZmV0Y2giLCJjdXN0b21GZXRjaFdpdGhSZXRyeSIsImJpbmQiLCJnZXRJbnN0YW5jZSIsIkVycm9yIiwiZ2V0SW5pdGlhbGl6YXRpb25TdGF0dXMiLCJnZXRDb25uZWN0aW9uRnJvbVBvb2wiLCJrZXkiLCJoYXMiLCJnZXQiLCJzaXplIiwib2xkZXN0S2V5Iiwia2V5cyIsIm5leHQiLCJ2YWx1ZSIsImRlbGV0ZSIsImNvbm5lY3Rpb24iLCJzZXQiLCJzZXRJbnRlcnZhbCIsInJlY3ljbGVDb25uZWN0aW9ucyIsImNvbm5lY3Rpb25zVG9SZW1vdmUiLCJmb3JFYWNoIiwicHVzaCIsImxlbmd0aCIsImlucHV0IiwiaW5pdCIsInN0YXJ0VGltZSIsImV4ZWN1dGUiLCJyZXNwb25zZSIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwidXBkYXRlSGVhbHRoIiwiZXJyb3IiLCJNYXRoIiwibWF4Iiwic3VjY2VzcyIsImVycm9yUmF0ZSIsImhlYWx0aENoZWNrSW50ZXJ2YWwiLCJwZXJmb3JtSGVhbHRoQ2hlY2siLCJkYXRhIiwiZnJvbSIsInNlbGVjdCIsImxpbWl0IiwibWVzc2FnZSIsImdldEhlYWx0aFN0YXR1cyIsImV4ZWN1dGVXaXRoUmV0cnkiLCJvcGVyYXRpb24iLCJjb250ZXh0IiwibGFzdEVycm9yIiwiYXR0ZW1wdCIsInJlc3VsdCIsImRlbGF5Iiwic2xlZXAiLCJtcyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInJlc2V0Q29ubmVjdGlvbiIsImNsZWFyIiwiY2xlYXJJbnRlcnZhbCIsImdldFN0YXRzIiwiaGVhbHRoIiwiZ2V0U3RhdHVzIiwic3RhdGUiLCJmYWlsdXJlQ291bnQiLCJtYXhTaXplIiwibGFzdFJlY3ljbGUiLCJkYiIsImluaXRpYWxpemVEYXRhYmFzZSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJhbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJTVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZIiwiZ2V0REJDbGllbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/db.ts\n");

/***/ }),

/***/ "(rsc)/./lib/utils/circuitBreaker.ts":
/*!*************************************!*\
  !*** ./lib/utils/circuitBreaker.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CircuitBreaker: () => (/* binding */ CircuitBreaker),\n/* harmony export */   CircuitBreakerManager: () => (/* binding */ CircuitBreakerManager),\n/* harmony export */   ServiceUnavailableError: () => (/* binding */ ServiceUnavailableError),\n/* harmony export */   circuitBreakerManager: () => (/* binding */ circuitBreakerManager)\n/* harmony export */ });\nclass CircuitBreaker {\n    constructor(options){\n        this.state = \"closed\";\n        this.failureCount = 0;\n        this.successCount = 0;\n        this.totalRequests = 0;\n        this.halfOpenAttempts = 0;\n        this.consecutiveSuccesses = 0;\n        this.metrics = {\n            totalExecutions: 0,\n            successfulExecutions: 0,\n            failedExecutions: 0,\n            circuitOpens: 0,\n            circuitCloses: 0,\n            averageResponseTime: 0\n        };\n        this.responseTimes = [];\n        this.options = {\n            monitoringWindow: 60000,\n            halfOpenMaxAttempts: 3,\n            ...options\n        };\n    }\n    async execute(fn) {\n        this.totalRequests++;\n        this.metrics.totalExecutions++;\n        // Ê£ÄÊü•Êñ≠Ë∑ØÂô®Áä∂ÊÄÅ\n        if (this.state === \"open\") {\n            if (this.shouldAttemptReset()) {\n                this.transitionToHalfOpen();\n            } else {\n                throw new ServiceUnavailableError(`Circuit breaker is open. Next attempt at ${this.nextAttemptTime?.toISOString()}`);\n            }\n        }\n        try {\n            const startTime = Date.now();\n            const result = await Promise.race([\n                fn(),\n                this.createTimeoutPromise()\n            ]);\n            const responseTime = Date.now() - startTime;\n            this.recordResponseTime(responseTime);\n            // Ê£ÄÊü•ÂìçÂ∫îÊó∂Èó¥\n            if (responseTime > this.options.expectedResponseTime) {\n                this.recordFailure(new Error(`Response time ${responseTime}ms exceeded threshold ${this.options.expectedResponseTime}ms`));\n                throw new Error(\"Response time exceeded threshold\");\n            }\n            this.recordSuccess();\n            return result;\n        } catch (error) {\n            this.recordFailure(error);\n            throw error;\n        }\n    }\n    createTimeoutPromise() {\n        return new Promise((_, reject)=>{\n            setTimeout(()=>{\n                reject(new Error(`Operation timeout after ${this.options.expectedResponseTime}ms`));\n            }, this.options.expectedResponseTime);\n        });\n    }\n    recordSuccess() {\n        this.successCount++;\n        this.lastSuccessTime = new Date();\n        this.consecutiveSuccesses++;\n        this.metrics.successfulExecutions++;\n        this.metrics.lastExecutionTime = new Date();\n        if (this.state === \"half-open\") {\n            this.halfOpenAttempts++;\n            // Â¶ÇÊûúÂçäÂºÄÁä∂ÊÄÅ‰∏ãËøûÁª≠ÊàêÂäüÊ¨°Êï∞ËææÂà∞ÈòàÂÄºÔºåÂÖ≥Èó≠Êñ≠Ë∑ØÂô®\n            if (this.consecutiveSuccesses >= this.options.halfOpenMaxAttempts) {\n                this.transitionToClosed();\n            }\n        } else if (this.state === \"closed\") {\n            // Âú®ÂÖ≥Èó≠Áä∂ÊÄÅ‰∏ãÔºåÈáçÁΩÆÂ§±Ë¥•ËÆ°Êï∞\n            this.failureCount = Math.max(0, this.failureCount - 1);\n        }\n    }\n    recordFailure(error) {\n        this.failureCount++;\n        this.lastFailureTime = new Date();\n        this.consecutiveSuccesses = 0;\n        this.metrics.failedExecutions++;\n        this.metrics.lastExecutionTime = new Date();\n        if (this.state === \"closed\" && this.failureCount >= this.options.failureThreshold) {\n            this.transitionToOpen();\n        } else if (this.state === \"half-open\") {\n            this.transitionToOpen();\n        }\n    }\n    transitionToOpen() {\n        this.state = \"open\";\n        this.nextAttemptTime = new Date(Date.now() + this.options.recoveryTimeout);\n        this.halfOpenAttempts = 0;\n        this.metrics.circuitOpens++;\n        console.warn(`üî¥ Circuit breaker opened. Next attempt at ${this.nextAttemptTime.toISOString()}`);\n    }\n    transitionToHalfOpen() {\n        this.state = \"half-open\";\n        this.halfOpenAttempts = 0;\n        this.consecutiveSuccesses = 0;\n        console.log(\"\\uD83D\\uDFE1 Circuit breaker half-open - testing connection\");\n    }\n    transitionToClosed() {\n        this.state = \"closed\";\n        this.failureCount = 0;\n        this.halfOpenAttempts = 0;\n        this.consecutiveSuccesses = 0;\n        this.metrics.circuitCloses++;\n        console.log(\"\\uD83D\\uDFE2 Circuit breaker closed - connection restored\");\n    }\n    shouldAttemptReset() {\n        if (!this.nextAttemptTime) return false;\n        return Date.now() >= this.nextAttemptTime.getTime();\n    }\n    recordResponseTime(responseTime) {\n        this.responseTimes.push(responseTime);\n        // ‰øùÊåÅÊúÄËøë100‰∏™ÂìçÂ∫îÊó∂Èó¥\n        if (this.responseTimes.length > 100) {\n            this.responseTimes = this.responseTimes.slice(-100);\n        }\n        // Êõ¥Êñ∞Âπ≥ÂùáÂìçÂ∫îÊó∂Èó¥\n        this.metrics.averageResponseTime = this.responseTimes.reduce((sum, time)=>sum + time, 0) / this.responseTimes.length;\n    }\n    getStatus() {\n        const errorRate = this.totalRequests > 0 ? this.failureCount / this.totalRequests : 0;\n        return {\n            state: this.state,\n            failureCount: this.failureCount,\n            successCount: this.successCount,\n            lastFailureTime: this.lastFailureTime,\n            lastSuccessTime: this.lastSuccessTime,\n            nextAttemptTime: this.nextAttemptTime,\n            totalRequests: this.totalRequests,\n            errorRate,\n            halfOpenAttempts: this.halfOpenAttempts,\n            consecutiveSuccesses: this.consecutiveSuccesses\n        };\n    }\n    getMetrics() {\n        return {\n            ...this.metrics\n        };\n    }\n    reset() {\n        this.state = \"closed\";\n        this.failureCount = 0;\n        this.successCount = 0;\n        this.lastFailureTime = undefined;\n        this.lastSuccessTime = undefined;\n        this.nextAttemptTime = undefined;\n        this.totalRequests = 0;\n        this.halfOpenAttempts = 0;\n        this.consecutiveSuccesses = 0;\n        this.responseTimes = [];\n        console.log(\"\\uD83D\\uDD04 Circuit breaker manually reset\");\n    }\n    forceOpen() {\n        this.transitionToOpen();\n    }\n    forceClose() {\n        this.transitionToClosed();\n    }\n    // Ëé∑ÂèñÊñ≠Ë∑ØÂô®ÈÖçÁΩÆ\n    getConfig() {\n        return {\n            ...this.options\n        };\n    }\n    // Êõ¥Êñ∞Êñ≠Ë∑ØÂô®ÈÖçÁΩÆ\n    updateConfig(newOptions) {\n        this.options = {\n            ...this.options,\n            ...newOptions\n        };\n        console.log(\"‚öôÔ∏è  Circuit breaker configuration updated\");\n    }\n}\n// Ëá™ÂÆö‰πâÈîôËØØÁ±ª\nclass ServiceUnavailableError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"ServiceUnavailableError\";\n    }\n}\n// Êñ≠Ë∑ØÂô®ÁÆ°ÁêÜÂô®\nclass CircuitBreakerManager {\n    constructor(defaultOptions){\n        this.breakers = new Map();\n        this.metrics = new Map();\n        this.defaultOptions = defaultOptions;\n    }\n    getBreaker(name, options) {\n        if (!this.breakers.has(name)) {\n            const breakerOptions = {\n                ...this.defaultOptions,\n                ...options\n            };\n            this.breakers.set(name, new CircuitBreaker(breakerOptions));\n        }\n        return this.breakers.get(name);\n    }\n    getStatus() {\n        const status = {};\n        this.breakers.forEach((breaker, name)=>{\n            status[name] = breaker.getStatus();\n        });\n        return status;\n    }\n    getMetrics() {\n        const metrics = {};\n        this.breakers.forEach((breaker, name)=>{\n            metrics[name] = breaker.getMetrics();\n        });\n        return metrics;\n    }\n    resetAll() {\n        this.breakers.forEach((breaker)=>breaker.reset());\n    }\n    forceOpenAll() {\n        this.breakers.forEach((breaker)=>breaker.forceOpen());\n    }\n    forceCloseAll() {\n        this.breakers.forEach((breaker)=>breaker.forceClose());\n    }\n    // Ëé∑ÂèñÊâÄÊúâÊñ≠Ë∑ØÂô®ÁöÑËÅöÂêàÁä∂ÊÄÅ\n    getAggregateStatus() {\n        const statuses = this.getStatus();\n        const totalBreakers = Object.keys(statuses).length;\n        const openBreakers = Object.values(statuses).filter((s)=>s.state === \"open\").length;\n        const halfOpenBreakers = Object.values(statuses).filter((s)=>s.state === \"half-open\").length;\n        const closedBreakers = Object.values(statuses).filter((s)=>s.state === \"closed\").length;\n        let overallHealth = \"healthy\";\n        if (openBreakers > 0) {\n            overallHealth = openBreakers > totalBreakers * 0.5 ? \"unhealthy\" : \"degraded\";\n        } else if (halfOpenBreakers > 0) {\n            overallHealth = \"degraded\";\n        }\n        return {\n            totalBreakers,\n            openBreakers,\n            halfOpenBreakers,\n            closedBreakers,\n            overallHealth\n        };\n    }\n}\n// ÂÖ®Â±ÄÊñ≠Ë∑ØÂô®ÁÆ°ÁêÜÂô®ÂÆû‰æã\nconst circuitBreakerManager = new CircuitBreakerManager({\n    failureThreshold: 5,\n    recoveryTimeout: 60000,\n    expectedResponseTime: 5000,\n    halfOpenMaxAttempts: 3\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDUSxPQUFPLENBQUNDLENBQUFBLFVBQVdBLFFBQVFqQixVQUFVO0lBQ3JEO0lBRUEsZUFBZTtJQUNmcUIscUJBTUU7UUFDQSxNQUFNQyxXQUFXLElBQUksQ0FBQzVCLFNBQVM7UUFDL0IsTUFBTTZCLGdCQUFnQkMsT0FBT0MsSUFBSSxDQUFDSCxVQUFVakMsTUFBTTtRQUNsRCxNQUFNcUMsZUFBZUYsT0FBT0csTUFBTSxDQUFDTCxVQUFVTSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUU5RixLQUFLLEtBQUssUUFBUXNELE1BQU07UUFDbkYsTUFBTXlDLG1CQUFtQk4sT0FBT0csTUFBTSxDQUFDTCxVQUFVTSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUU5RixLQUFLLEtBQUssYUFBYXNELE1BQU07UUFDNUYsTUFBTTBDLGlCQUFpQlAsT0FBT0csTUFBTSxDQUFDTCxVQUFVTSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUU5RixLQUFLLEtBQUssVUFBVXNELE1BQU07UUFFdkYsSUFBSTJDLGdCQUFzRDtRQUUxRCxJQUFJTixlQUFlLEdBQUc7WUFDcEJNLGdCQUFnQk4sZUFBZUgsZ0JBQWdCLE1BQU0sY0FBYztRQUNyRSxPQUFPLElBQUlPLG1CQUFtQixHQUFHO1lBQy9CRSxnQkFBZ0I7UUFDbEI7UUFFQSxPQUFPO1lBQ0xUO1lBQ0FHO1lBQ0FJO1lBQ0FDO1lBQ0FDO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsYUFBYTtBQUNOLE1BQU1DLHdCQUF3QixJQUFJM0Isc0JBQXNCO0lBQzdEekIsa0JBQWtCO0lBQ2xCRSxpQkFBaUI7SUFDakJoQixzQkFBc0I7SUFDdEJqQixxQkFBcUI7QUFDdkIsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsaW5rLy4vbGliL3V0aWxzL2NpcmN1aXRCcmVha2VyLnRzP2Y1MmYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGludGVyZmFjZSBDaXJjdWl0QnJlYWtlck9wdGlvbnMge1xuICBmYWlsdXJlVGhyZXNob2xkOiBudW1iZXI7XG4gIHJlY292ZXJ5VGltZW91dDogbnVtYmVyO1xuICBleHBlY3RlZFJlc3BvbnNlVGltZTogbnVtYmVyO1xuICBtb25pdG9yaW5nV2luZG93PzogbnVtYmVyO1xuICBoYWxmT3Blbk1heEF0dGVtcHRzPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENpcmN1aXRCcmVha2VyU3RhdHVzIHtcbiAgc3RhdGU6ICdjbG9zZWQnIHwgJ29wZW4nIHwgJ2hhbGYtb3Blbic7XG4gIGZhaWx1cmVDb3VudDogbnVtYmVyO1xuICBzdWNjZXNzQ291bnQ6IG51bWJlcjtcbiAgbGFzdEZhaWx1cmVUaW1lPzogRGF0ZTtcbiAgbGFzdFN1Y2Nlc3NUaW1lPzogRGF0ZTtcbiAgbmV4dEF0dGVtcHRUaW1lPzogRGF0ZTtcbiAgdG90YWxSZXF1ZXN0czogbnVtYmVyO1xuICBlcnJvclJhdGU6IG51bWJlcjtcbiAgaGFsZk9wZW5BdHRlbXB0czogbnVtYmVyO1xuICBjb25zZWN1dGl2ZVN1Y2Nlc3NlczogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENpcmN1aXRCcmVha2VyTWV0cmljcyB7XG4gIHRvdGFsRXhlY3V0aW9uczogbnVtYmVyO1xuICBzdWNjZXNzZnVsRXhlY3V0aW9uczogbnVtYmVyO1xuICBmYWlsZWRFeGVjdXRpb25zOiBudW1iZXI7XG4gIGNpcmN1aXRPcGVuczogbnVtYmVyO1xuICBjaXJjdWl0Q2xvc2VzOiBudW1iZXI7XG4gIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IG51bWJlcjtcbiAgbGFzdEV4ZWN1dGlvblRpbWU/OiBEYXRlO1xufVxuXG5leHBvcnQgY2xhc3MgQ2lyY3VpdEJyZWFrZXIge1xuICBwcml2YXRlIHN0YXRlOiAnY2xvc2VkJyB8ICdvcGVuJyB8ICdoYWxmLW9wZW4nID0gJ2Nsb3NlZCc7XG4gIHByaXZhdGUgZmFpbHVyZUNvdW50ID0gMDtcbiAgcHJpdmF0ZSBzdWNjZXNzQ291bnQgPSAwO1xuICBwcml2YXRlIGxhc3RGYWlsdXJlVGltZT86IERhdGU7XG4gIHByaXZhdGUgbGFzdFN1Y2Nlc3NUaW1lPzogRGF0ZTtcbiAgcHJpdmF0ZSBuZXh0QXR0ZW1wdFRpbWU/OiBEYXRlO1xuICBwcml2YXRlIHRvdGFsUmVxdWVzdHMgPSAwO1xuICBwcml2YXRlIGhhbGZPcGVuQXR0ZW1wdHMgPSAwO1xuICBwcml2YXRlIGNvbnNlY3V0aXZlU3VjY2Vzc2VzID0gMDtcbiAgcHJpdmF0ZSBvcHRpb25zOiBDaXJjdWl0QnJlYWtlck9wdGlvbnM7XG4gIHByaXZhdGUgbWV0cmljczogQ2lyY3VpdEJyZWFrZXJNZXRyaWNzID0ge1xuICAgIHRvdGFsRXhlY3V0aW9uczogMCxcbiAgICBzdWNjZXNzZnVsRXhlY3V0aW9uczogMCxcbiAgICBmYWlsZWRFeGVjdXRpb25zOiAwLFxuICAgIGNpcmN1aXRPcGVuczogMCxcbiAgICBjaXJjdWl0Q2xvc2VzOiAwLFxuICAgIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IDBcbiAgfTtcbiAgcHJpdmF0ZSByZXNwb25zZVRpbWVzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IENpcmN1aXRCcmVha2VyT3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIG1vbml0b3JpbmdXaW5kb3c6IDYwMDAwLCAvLyAxIG1pbnV0ZSBkZWZhdWx0XG4gICAgICBoYWxmT3Blbk1heEF0dGVtcHRzOiAzLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gIH1cblxuICBhc3luYyBleGVjdXRlPFQ+KGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgdGhpcy50b3RhbFJlcXVlc3RzKys7XG4gICAgdGhpcy5tZXRyaWNzLnRvdGFsRXhlY3V0aW9ucysrO1xuXG4gICAgLy8g5qOA5p+l5pat6Lev5Zmo54q25oCBXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgaWYgKHRoaXMuc2hvdWxkQXR0ZW1wdFJlc2V0KCkpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9IYWxmT3BlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFNlcnZpY2VVbmF2YWlsYWJsZUVycm9yKFxuICAgICAgICAgIGBDaXJjdWl0IGJyZWFrZXIgaXMgb3Blbi4gTmV4dCBhdHRlbXB0IGF0ICR7dGhpcy5uZXh0QXR0ZW1wdFRpbWU/LnRvSVNPU3RyaW5nKCl9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgZm4oKSxcbiAgICAgICAgdGhpcy5jcmVhdGVUaW1lb3V0UHJvbWlzZSgpXG4gICAgICBdKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIHRoaXMucmVjb3JkUmVzcG9uc2VUaW1lKHJlc3BvbnNlVGltZSk7XG4gICAgICBcbiAgICAgIC8vIOajgOafpeWTjeW6lOaXtumXtFxuICAgICAgaWYgKHJlc3BvbnNlVGltZSA+IHRoaXMub3B0aW9ucy5leHBlY3RlZFJlc3BvbnNlVGltZSkge1xuICAgICAgICB0aGlzLnJlY29yZEZhaWx1cmUobmV3IEVycm9yKGBSZXNwb25zZSB0aW1lICR7cmVzcG9uc2VUaW1lfW1zIGV4Y2VlZGVkIHRocmVzaG9sZCAke3RoaXMub3B0aW9ucy5leHBlY3RlZFJlc3BvbnNlVGltZX1tc2ApKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSB0aW1lIGV4Y2VlZGVkIHRocmVzaG9sZCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlY29yZFN1Y2Nlc3MoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMucmVjb3JkRmFpbHVyZShlcnJvciBhcyBFcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVRpbWVvdXRQcm9taXNlKCk6IFByb21pc2U8bmV2ZXI+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYE9wZXJhdGlvbiB0aW1lb3V0IGFmdGVyICR7dGhpcy5vcHRpb25zLmV4cGVjdGVkUmVzcG9uc2VUaW1lfW1zYCkpO1xuICAgICAgfSwgdGhpcy5vcHRpb25zLmV4cGVjdGVkUmVzcG9uc2VUaW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcmVjb3JkU3VjY2VzcygpOiB2b2lkIHtcbiAgICB0aGlzLnN1Y2Nlc3NDb3VudCsrO1xuICAgIHRoaXMubGFzdFN1Y2Nlc3NUaW1lID0gbmV3IERhdGUoKTtcbiAgICB0aGlzLmNvbnNlY3V0aXZlU3VjY2Vzc2VzKys7XG4gICAgdGhpcy5tZXRyaWNzLnN1Y2Nlc3NmdWxFeGVjdXRpb25zKys7XG4gICAgdGhpcy5tZXRyaWNzLmxhc3RFeGVjdXRpb25UaW1lID0gbmV3IERhdGUoKTtcblxuICAgIGlmICh0aGlzLnN0YXRlID09PSAnaGFsZi1vcGVuJykge1xuICAgICAgdGhpcy5oYWxmT3BlbkF0dGVtcHRzKys7XG4gICAgICBcbiAgICAgIC8vIOWmguaenOWNiuW8gOeKtuaAgeS4i+i/nue7reaIkOWKn+asoeaVsOi+vuWIsOmYiOWAvO+8jOWFs+mXreaWrei3r+WZqFxuICAgICAgaWYgKHRoaXMuY29uc2VjdXRpdmVTdWNjZXNzZXMgPj0gdGhpcy5vcHRpb25zLmhhbGZPcGVuTWF4QXR0ZW1wdHMhKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblRvQ2xvc2VkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgLy8g5Zyo5YWz6Zet54q25oCB5LiL77yM6YeN572u5aSx6LSl6K6h5pWwXG4gICAgICB0aGlzLmZhaWx1cmVDb3VudCA9IE1hdGgubWF4KDAsIHRoaXMuZmFpbHVyZUNvdW50IC0gMSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZWNvcmRGYWlsdXJlKGVycm9yOiBFcnJvcik6IHZvaWQge1xuICAgIHRoaXMuZmFpbHVyZUNvdW50Kys7XG4gICAgdGhpcy5sYXN0RmFpbHVyZVRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgIHRoaXMuY29uc2VjdXRpdmVTdWNjZXNzZXMgPSAwO1xuICAgIHRoaXMubWV0cmljcy5mYWlsZWRFeGVjdXRpb25zKys7XG4gICAgdGhpcy5tZXRyaWNzLmxhc3RFeGVjdXRpb25UaW1lID0gbmV3IERhdGUoKTtcblxuICAgIGlmICh0aGlzLnN0YXRlID09PSAnY2xvc2VkJyAmJiB0aGlzLmZhaWx1cmVDb3VudCA+PSB0aGlzLm9wdGlvbnMuZmFpbHVyZVRocmVzaG9sZCkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uVG9PcGVuKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnaGFsZi1vcGVuJykge1xuICAgICAgdGhpcy50cmFuc2l0aW9uVG9PcGVuKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmFuc2l0aW9uVG9PcGVuKCk6IHZvaWQge1xuICAgIHRoaXMuc3RhdGUgPSAnb3Blbic7XG4gICAgdGhpcy5uZXh0QXR0ZW1wdFRpbWUgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgdGhpcy5vcHRpb25zLnJlY292ZXJ5VGltZW91dCk7XG4gICAgdGhpcy5oYWxmT3BlbkF0dGVtcHRzID0gMDtcbiAgICB0aGlzLm1ldHJpY3MuY2lyY3VpdE9wZW5zKys7XG4gICAgXG4gICAgY29uc29sZS53YXJuKGDwn5S0IENpcmN1aXQgYnJlYWtlciBvcGVuZWQuIE5leHQgYXR0ZW1wdCBhdCAke3RoaXMubmV4dEF0dGVtcHRUaW1lLnRvSVNPU3RyaW5nKCl9YCk7XG4gIH1cblxuICBwcml2YXRlIHRyYW5zaXRpb25Ub0hhbGZPcGVuKCk6IHZvaWQge1xuICAgIHRoaXMuc3RhdGUgPSAnaGFsZi1vcGVuJztcbiAgICB0aGlzLmhhbGZPcGVuQXR0ZW1wdHMgPSAwO1xuICAgIHRoaXMuY29uc2VjdXRpdmVTdWNjZXNzZXMgPSAwO1xuICAgIGNvbnNvbGUubG9nKCfwn5+hIENpcmN1aXQgYnJlYWtlciBoYWxmLW9wZW4gLSB0ZXN0aW5nIGNvbm5lY3Rpb24nKTtcbiAgfVxuXG4gIHByaXZhdGUgdHJhbnNpdGlvblRvQ2xvc2VkKCk6IHZvaWQge1xuICAgIHRoaXMuc3RhdGUgPSAnY2xvc2VkJztcbiAgICB0aGlzLmZhaWx1cmVDb3VudCA9IDA7XG4gICAgdGhpcy5oYWxmT3BlbkF0dGVtcHRzID0gMDtcbiAgICB0aGlzLmNvbnNlY3V0aXZlU3VjY2Vzc2VzID0gMDtcbiAgICB0aGlzLm1ldHJpY3MuY2lyY3VpdENsb3NlcysrO1xuICAgIGNvbnNvbGUubG9nKCfwn5+iIENpcmN1aXQgYnJlYWtlciBjbG9zZWQgLSBjb25uZWN0aW9uIHJlc3RvcmVkJyk7XG4gIH1cblxuICBwcml2YXRlIHNob3VsZEF0dGVtcHRSZXNldCgpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMubmV4dEF0dGVtcHRUaW1lKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIERhdGUubm93KCkgPj0gdGhpcy5uZXh0QXR0ZW1wdFRpbWUuZ2V0VGltZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWNvcmRSZXNwb25zZVRpbWUocmVzcG9uc2VUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnJlc3BvbnNlVGltZXMucHVzaChyZXNwb25zZVRpbWUpO1xuICAgIFxuICAgIC8vIOS/neaMgeacgOi/kTEwMOS4quWTjeW6lOaXtumXtFxuICAgIGlmICh0aGlzLnJlc3BvbnNlVGltZXMubGVuZ3RoID4gMTAwKSB7XG4gICAgICB0aGlzLnJlc3BvbnNlVGltZXMgPSB0aGlzLnJlc3BvbnNlVGltZXMuc2xpY2UoLTEwMCk7XG4gICAgfVxuICAgIFxuICAgIC8vIOabtOaWsOW5s+Wdh+WTjeW6lOaXtumXtFxuICAgIHRoaXMubWV0cmljcy5hdmVyYWdlUmVzcG9uc2VUaW1lID0gdGhpcy5yZXNwb25zZVRpbWVzLnJlZHVjZSgoc3VtLCB0aW1lKSA9PiBzdW0gKyB0aW1lLCAwKSAvIHRoaXMucmVzcG9uc2VUaW1lcy5sZW5ndGg7XG4gIH1cblxuICBnZXRTdGF0dXMoKTogQ2lyY3VpdEJyZWFrZXJTdGF0dXMge1xuICAgIGNvbnN0IGVycm9yUmF0ZSA9IHRoaXMudG90YWxSZXF1ZXN0cyA+IDAgPyB0aGlzLmZhaWx1cmVDb3VudCAvIHRoaXMudG90YWxSZXF1ZXN0cyA6IDA7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgZmFpbHVyZUNvdW50OiB0aGlzLmZhaWx1cmVDb3VudCxcbiAgICAgIHN1Y2Nlc3NDb3VudDogdGhpcy5zdWNjZXNzQ291bnQsXG4gICAgICBsYXN0RmFpbHVyZVRpbWU6IHRoaXMubGFzdEZhaWx1cmVUaW1lLFxuICAgICAgbGFzdFN1Y2Nlc3NUaW1lOiB0aGlzLmxhc3RTdWNjZXNzVGltZSxcbiAgICAgIG5leHRBdHRlbXB0VGltZTogdGhpcy5uZXh0QXR0ZW1wdFRpbWUsXG4gICAgICB0b3RhbFJlcXVlc3RzOiB0aGlzLnRvdGFsUmVxdWVzdHMsXG4gICAgICBlcnJvclJhdGUsXG4gICAgICBoYWxmT3BlbkF0dGVtcHRzOiB0aGlzLmhhbGZPcGVuQXR0ZW1wdHMsXG4gICAgICBjb25zZWN1dGl2ZVN1Y2Nlc3NlczogdGhpcy5jb25zZWN1dGl2ZVN1Y2Nlc3Nlc1xuICAgIH07XG4gIH1cblxuICBnZXRNZXRyaWNzKCk6IENpcmN1aXRCcmVha2VyTWV0cmljcyB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5tZXRyaWNzIH07XG4gIH1cblxuICByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLnN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgdGhpcy5mYWlsdXJlQ291bnQgPSAwO1xuICAgIHRoaXMuc3VjY2Vzc0NvdW50ID0gMDtcbiAgICB0aGlzLmxhc3RGYWlsdXJlVGltZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhc3RTdWNjZXNzVGltZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm5leHRBdHRlbXB0VGltZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvdGFsUmVxdWVzdHMgPSAwO1xuICAgIHRoaXMuaGFsZk9wZW5BdHRlbXB0cyA9IDA7XG4gICAgdGhpcy5jb25zZWN1dGl2ZVN1Y2Nlc3NlcyA9IDA7XG4gICAgdGhpcy5yZXNwb25zZVRpbWVzID0gW107XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CflIQgQ2lyY3VpdCBicmVha2VyIG1hbnVhbGx5IHJlc2V0Jyk7XG4gIH1cblxuICBmb3JjZU9wZW4oKTogdm9pZCB7XG4gICAgdGhpcy50cmFuc2l0aW9uVG9PcGVuKCk7XG4gIH1cblxuICBmb3JjZUNsb3NlKCk6IHZvaWQge1xuICAgIHRoaXMudHJhbnNpdGlvblRvQ2xvc2VkKCk7XG4gIH1cblxuICAvLyDojrflj5bmlq3ot6/lmajphY3nva5cbiAgZ2V0Q29uZmlnKCk6IENpcmN1aXRCcmVha2VyT3B0aW9ucyB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5vcHRpb25zIH07XG4gIH1cblxuICAvLyDmm7TmlrDmlq3ot6/lmajphY3nva5cbiAgdXBkYXRlQ29uZmlnKG5ld09wdGlvbnM6IFBhcnRpYWw8Q2lyY3VpdEJyZWFrZXJPcHRpb25zPik6IHZvaWQge1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zLCAuLi5uZXdPcHRpb25zIH07XG4gICAgY29uc29sZS5sb2coJ+Kame+4jyAgQ2lyY3VpdCBicmVha2VyIGNvbmZpZ3VyYXRpb24gdXBkYXRlZCcpO1xuICB9XG59XG5cbi8vIOiHquWumuS5iemUmeivr+exu1xuZXhwb3J0IGNsYXNzIFNlcnZpY2VVbmF2YWlsYWJsZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnU2VydmljZVVuYXZhaWxhYmxlRXJyb3InO1xuICB9XG59XG5cbi8vIOaWrei3r+WZqOeuoeeQhuWZqFxuZXhwb3J0IGNsYXNzIENpcmN1aXRCcmVha2VyTWFuYWdlciB7XG4gIHByaXZhdGUgYnJlYWtlcnM6IE1hcDxzdHJpbmcsIENpcmN1aXRCcmVha2VyPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBkZWZhdWx0T3B0aW9uczogQ2lyY3VpdEJyZWFrZXJPcHRpb25zO1xuICBwcml2YXRlIG1ldHJpY3M6IE1hcDxzdHJpbmcsIENpcmN1aXRCcmVha2VyTWV0cmljcz4gPSBuZXcgTWFwKCk7XG5cbiAgY29uc3RydWN0b3IoZGVmYXVsdE9wdGlvbnM6IENpcmN1aXRCcmVha2VyT3B0aW9ucykge1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgfVxuXG4gIGdldEJyZWFrZXIobmFtZTogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxDaXJjdWl0QnJlYWtlck9wdGlvbnM+KTogQ2lyY3VpdEJyZWFrZXIge1xuICAgIGlmICghdGhpcy5icmVha2Vycy5oYXMobmFtZSkpIHtcbiAgICAgIGNvbnN0IGJyZWFrZXJPcHRpb25zID0geyAuLi50aGlzLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICB0aGlzLmJyZWFrZXJzLnNldChuYW1lLCBuZXcgQ2lyY3VpdEJyZWFrZXIoYnJlYWtlck9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnJlYWtlcnMuZ2V0KG5hbWUpITtcbiAgfVxuXG4gIGdldFN0YXR1cygpOiBSZWNvcmQ8c3RyaW5nLCBDaXJjdWl0QnJlYWtlclN0YXR1cz4ge1xuICAgIGNvbnN0IHN0YXR1czogUmVjb3JkPHN0cmluZywgQ2lyY3VpdEJyZWFrZXJTdGF0dXM+ID0ge307XG4gICAgdGhpcy5icmVha2Vycy5mb3JFYWNoKChicmVha2VyLCBuYW1lKSA9PiB7XG4gICAgICBzdGF0dXNbbmFtZV0gPSBicmVha2VyLmdldFN0YXR1cygpO1xuICAgIH0pO1xuICAgIHJldHVybiBzdGF0dXM7XG4gIH1cblxuICBnZXRNZXRyaWNzKCk6IFJlY29yZDxzdHJpbmcsIENpcmN1aXRCcmVha2VyTWV0cmljcz4ge1xuICAgIGNvbnN0IG1ldHJpY3M6IFJlY29yZDxzdHJpbmcsIENpcmN1aXRCcmVha2VyTWV0cmljcz4gPSB7fTtcbiAgICB0aGlzLmJyZWFrZXJzLmZvckVhY2goKGJyZWFrZXIsIG5hbWUpID0+IHtcbiAgICAgIG1ldHJpY3NbbmFtZV0gPSBicmVha2VyLmdldE1ldHJpY3MoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWV0cmljcztcbiAgfVxuXG4gIHJlc2V0QWxsKCk6IHZvaWQge1xuICAgIHRoaXMuYnJlYWtlcnMuZm9yRWFjaChicmVha2VyID0+IGJyZWFrZXIucmVzZXQoKSk7XG4gIH1cblxuICBmb3JjZU9wZW5BbGwoKTogdm9pZCB7XG4gICAgdGhpcy5icmVha2Vycy5mb3JFYWNoKGJyZWFrZXIgPT4gYnJlYWtlci5mb3JjZU9wZW4oKSk7XG4gIH1cblxuICBmb3JjZUNsb3NlQWxsKCk6IHZvaWQge1xuICAgIHRoaXMuYnJlYWtlcnMuZm9yRWFjaChicmVha2VyID0+IGJyZWFrZXIuZm9yY2VDbG9zZSgpKTtcbiAgfVxuXG4gIC8vIOiOt+WPluaJgOacieaWrei3r+WZqOeahOiBmuWQiOeKtuaAgVxuICBnZXRBZ2dyZWdhdGVTdGF0dXMoKToge1xuICAgIHRvdGFsQnJlYWtlcnM6IG51bWJlcjtcbiAgICBvcGVuQnJlYWtlcnM6IG51bWJlcjtcbiAgICBoYWxmT3BlbkJyZWFrZXJzOiBudW1iZXI7XG4gICAgY2xvc2VkQnJlYWtlcnM6IG51bWJlcjtcbiAgICBvdmVyYWxsSGVhbHRoOiAnaGVhbHRoeScgfCAnZGVncmFkZWQnIHwgJ3VuaGVhbHRoeSc7XG4gIH0ge1xuICAgIGNvbnN0IHN0YXR1c2VzID0gdGhpcy5nZXRTdGF0dXMoKTtcbiAgICBjb25zdCB0b3RhbEJyZWFrZXJzID0gT2JqZWN0LmtleXMoc3RhdHVzZXMpLmxlbmd0aDtcbiAgICBjb25zdCBvcGVuQnJlYWtlcnMgPSBPYmplY3QudmFsdWVzKHN0YXR1c2VzKS5maWx0ZXIocyA9PiBzLnN0YXRlID09PSAnb3BlbicpLmxlbmd0aDtcbiAgICBjb25zdCBoYWxmT3BlbkJyZWFrZXJzID0gT2JqZWN0LnZhbHVlcyhzdGF0dXNlcykuZmlsdGVyKHMgPT4gcy5zdGF0ZSA9PT0gJ2hhbGYtb3BlbicpLmxlbmd0aDtcbiAgICBjb25zdCBjbG9zZWRCcmVha2VycyA9IE9iamVjdC52YWx1ZXMoc3RhdHVzZXMpLmZpbHRlcihzID0+IHMuc3RhdGUgPT09ICdjbG9zZWQnKS5sZW5ndGg7XG5cbiAgICBsZXQgb3ZlcmFsbEhlYWx0aDogJ2hlYWx0aHknIHwgJ2RlZ3JhZGVkJyB8ICd1bmhlYWx0aHknID0gJ2hlYWx0aHknO1xuICAgIFxuICAgIGlmIChvcGVuQnJlYWtlcnMgPiAwKSB7XG4gICAgICBvdmVyYWxsSGVhbHRoID0gb3BlbkJyZWFrZXJzID4gdG90YWxCcmVha2VycyAqIDAuNSA/ICd1bmhlYWx0aHknIDogJ2RlZ3JhZGVkJztcbiAgICB9IGVsc2UgaWYgKGhhbGZPcGVuQnJlYWtlcnMgPiAwKSB7XG4gICAgICBvdmVyYWxsSGVhbHRoID0gJ2RlZ3JhZGVkJztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxCcmVha2VycyxcbiAgICAgIG9wZW5CcmVha2VycyxcbiAgICAgIGhhbGZPcGVuQnJlYWtlcnMsXG4gICAgICBjbG9zZWRCcmVha2VycyxcbiAgICAgIG92ZXJhbGxIZWFsdGhcbiAgICB9O1xuICB9XG59XG5cbi8vIOWFqOWxgOaWrei3r+WZqOeuoeeQhuWZqOWunuS+i1xuZXhwb3J0IGNvbnN0IGNpcmN1aXRCcmVha2VyTWFuYWdlciA9IG5ldyBDaXJjdWl0QnJlYWtlck1hbmFnZXIoe1xuICBmYWlsdXJlVGhyZXNob2xkOiA1LFxuICByZWNvdmVyeVRpbWVvdXQ6IDYwMDAwLFxuICBleHBlY3RlZFJlc3BvbnNlVGltZTogNTAwMCxcbiAgaGFsZk9wZW5NYXhBdHRlbXB0czogM1xufSk7ICJdLCJuYW1lcyI6WyJDaXJjdWl0QnJlYWtlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsInN0YXRlIiwiZmFpbHVyZUNvdW50Iiwic3VjY2Vzc0NvdW50IiwidG90YWxSZXF1ZXN0cyIsImhhbGZPcGVuQXR0ZW1wdHMiLCJjb25zZWN1dGl2ZVN1Y2Nlc3NlcyIsIm1ldHJpY3MiLCJ0b3RhbEV4ZWN1dGlvbnMiLCJzdWNjZXNzZnVsRXhlY3V0aW9ucyIsImZhaWxlZEV4ZWN1dGlvbnMiLCJjaXJjdWl0T3BlbnMiLCJjaXJjdWl0Q2xvc2VzIiwiYXZlcmFnZVJlc3BvbnNlVGltZSIsInJlc3BvbnNlVGltZXMiLCJtb25pdG9yaW5nV2luZG93IiwiaGFsZk9wZW5NYXhBdHRlbXB0cyIsImV4ZWN1dGUiLCJmbiIsInNob3VsZEF0dGVtcHRSZXNldCIsInRyYW5zaXRpb25Ub0hhbGZPcGVuIiwiU2VydmljZVVuYXZhaWxhYmxlRXJyb3IiLCJuZXh0QXR0ZW1wdFRpbWUiLCJ0b0lTT1N0cmluZyIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJyZXN1bHQiLCJQcm9taXNlIiwicmFjZSIsImNyZWF0ZVRpbWVvdXRQcm9taXNlIiwicmVzcG9uc2VUaW1lIiwicmVjb3JkUmVzcG9uc2VUaW1lIiwiZXhwZWN0ZWRSZXNwb25zZVRpbWUiLCJyZWNvcmRGYWlsdXJlIiwiRXJyb3IiLCJyZWNvcmRTdWNjZXNzIiwiZXJyb3IiLCJfIiwicmVqZWN0Iiwic2V0VGltZW91dCIsImxhc3RTdWNjZXNzVGltZSIsImxhc3RFeGVjdXRpb25UaW1lIiwidHJhbnNpdGlvblRvQ2xvc2VkIiwiTWF0aCIsIm1heCIsImxhc3RGYWlsdXJlVGltZSIsImZhaWx1cmVUaHJlc2hvbGQiLCJ0cmFuc2l0aW9uVG9PcGVuIiwicmVjb3ZlcnlUaW1lb3V0IiwiY29uc29sZSIsIndhcm4iLCJsb2ciLCJnZXRUaW1lIiwicHVzaCIsImxlbmd0aCIsInNsaWNlIiwicmVkdWNlIiwic3VtIiwidGltZSIsImdldFN0YXR1cyIsImVycm9yUmF0ZSIsImdldE1ldHJpY3MiLCJyZXNldCIsInVuZGVmaW5lZCIsImZvcmNlT3BlbiIsImZvcmNlQ2xvc2UiLCJnZXRDb25maWciLCJ1cGRhdGVDb25maWciLCJuZXdPcHRpb25zIiwibWVzc2FnZSIsIm5hbWUiLCJDaXJjdWl0QnJlYWtlck1hbmFnZXIiLCJkZWZhdWx0T3B0aW9ucyIsImJyZWFrZXJzIiwiTWFwIiwiZ2V0QnJlYWtlciIsImhhcyIsImJyZWFrZXJPcHRpb25zIiwic2V0IiwiZ2V0Iiwic3RhdHVzIiwiZm9yRWFjaCIsImJyZWFrZXIiLCJyZXNldEFsbCIsImZvcmNlT3BlbkFsbCIsImZvcmNlQ2xvc2VBbGwiLCJnZXRBZ2dyZWdhdGVTdGF0dXMiLCJzdGF0dXNlcyIsInRvdGFsQnJlYWtlcnMiLCJPYmplY3QiLCJrZXlzIiwib3BlbkJyZWFrZXJzIiwidmFsdWVzIiwiZmlsdGVyIiwicyIsImhhbGZPcGVuQnJlYWtlcnMiLCJjbG9zZWRCcmVha2VycyIsIm92ZXJhbGxIZWFsdGgiLCJjaXJjdWl0QnJlYWtlck1hbmFnZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/utils/circuitBreaker.ts\n");

/***/ }),

/***/ "(rsc)/./lib/utils/retry.ts":
/*!****************************!*\
  !*** ./lib/utils/retry.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Retryable: () => (/* binding */ Retryable),\n/* harmony export */   exponentialBackoff: () => (/* binding */ exponentialBackoff),\n/* harmony export */   isTransientError: () => (/* binding */ isTransientError),\n/* harmony export */   withBatchRetry: () => (/* binding */ withBatchRetry),\n/* harmony export */   withConditionalRetry: () => (/* binding */ withConditionalRetry),\n/* harmony export */   withRetry: () => (/* binding */ withRetry),\n/* harmony export */   withRetryAndTimeout: () => (/* binding */ withRetryAndTimeout)\n/* harmony export */ });\n// ÈîôËØØÂàÜÁ±ª\nfunction isTransientError(error) {\n    if (!error) return false;\n    const transientErrorCodes = [\n        \"PGRST301\",\n        \"PGRST302\",\n        \"PGRST303\",\n        \"PGRST304\",\n        \"PGRST305\",\n        \"ECONNRESET\",\n        \"ECONNREFUSED\",\n        \"ETIMEDOUT\",\n        \"ENOTFOUND\"\n    ];\n    const transientErrorMessages = [\n        \"timeout\",\n        \"connection\",\n        \"network\",\n        \"temporary\",\n        \"retry\",\n        \"rate limit\",\n        \"too many requests\",\n        \"service unavailable\",\n        \"internal server error\"\n    ];\n    // Ê£ÄÊü•ÈîôËØØ‰ª£Á†Å\n    if (error.code && transientErrorCodes.includes(error.code)) {\n        return true;\n    }\n    // Ê£ÄÊü•ÈîôËØØÊ∂àÊÅØ\n    if (error.message) {\n        const lowerMessage = error.message.toLowerCase();\n        return transientErrorMessages.some((msg)=>lowerMessage.includes(msg));\n    }\n    // Ê£ÄÊü• HTTP Áä∂ÊÄÅÁ†Å\n    if (error.status) {\n        return [\n            408,\n            429,\n            500,\n            502,\n            503,\n            504\n        ].includes(error.status);\n    }\n    return false;\n}\n// ÊåáÊï∞ÈÄÄÈÅøÁÆóÊ≥ï\nfunction exponentialBackoff(attempt, baseDelay = 1000, maxDelay = 30000, backoffMultiplier = 2) {\n    const delay = Math.min(baseDelay * Math.pow(backoffMultiplier, attempt - 1), maxDelay);\n    // Ê∑ªÂä†ÈöèÊú∫ÊäñÂä®‰ª•ÈÅøÂÖçÊÉäÁæ§ÊïàÂ∫î\n    const jitter = delay * 0.1 * Math.random();\n    return delay + jitter;\n}\n// Êô∫ËÉΩÈáçËØïÂáΩÊï∞\nasync function withRetry(fn, options = {}) {\n    const { maxRetries = 3, baseDelay = 1000, maxDelay = 30000, backoffMultiplier = 2, jitter = true } = options;\n    const startTime = Date.now();\n    let lastError = null;\n    for(let attempt = 1; attempt <= maxRetries + 1; attempt++){\n        try {\n            const result = await fn();\n            const totalTime = Date.now() - startTime;\n            return {\n                result,\n                attempts: attempt,\n                totalTime\n            };\n        } catch (error) {\n            lastError = error;\n            // Â¶ÇÊûú‰∏çÊòØ‰∏¥Êó∂ÈîôËØØÔºåÁõ¥Êé•ÊäõÂá∫\n            if (!isTransientError(error)) {\n                throw error;\n            }\n            // Â¶ÇÊûúÂ∑≤ÁªèËææÂà∞ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞ÔºåÊäõÂá∫ÈîôËØØ\n            if (attempt > maxRetries) {\n                break;\n            }\n            // ËÆ°ÁÆóÂª∂ËøüÊó∂Èó¥\n            const delay = jitter ? exponentialBackoff(attempt, baseDelay, maxDelay, backoffMultiplier) : baseDelay * Math.pow(backoffMultiplier, attempt - 1);\n            console.log(`‚ö†Ô∏è  Attempt ${attempt} failed, retrying in ${delay}ms...`);\n            await sleep(delay);\n        }\n    }\n    const totalTime = Date.now() - startTime;\n    throw new Error(`Operation failed after ${maxRetries + 1} attempts (${totalTime}ms): ${lastError?.message}`);\n}\n// Â∏¶Ë∂ÖÊó∂ÁöÑÈáçËØïÂáΩÊï∞\nasync function withRetryAndTimeout(fn, timeout = 30000, retryOptions = {}) {\n    return withRetry(()=>Promise.race([\n            fn(),\n            new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Operation timeout\")), timeout))\n        ]), retryOptions);\n}\n// ÊâπÈáèÈáçËØïÂáΩÊï∞\nasync function withBatchRetry(items, processor, options = {}) {\n    const { concurrency = 5, stopOnError = false, ...retryOptions } = options;\n    const results = [];\n    const errors = [];\n    // ÂàÜÊâπÂ§ÑÁêÜ\n    for(let i = 0; i < items.length; i += concurrency){\n        const batch = items.slice(i, i + concurrency);\n        const batchPromises = batch.map(async (item)=>{\n            try {\n                const result = await withRetry(()=>processor(item), retryOptions);\n                return {\n                    success: true,\n                    item,\n                    result: result.result\n                };\n            } catch (error) {\n                if (stopOnError) {\n                    throw error;\n                }\n                return {\n                    success: false,\n                    item,\n                    error: error\n                };\n            }\n        });\n        const batchResults = await Promise.allSettled(batchPromises);\n        batchResults.forEach((result)=>{\n            if (result.status === \"fulfilled\") {\n                if (result.value.success) {\n                    results.push(result.value.result);\n                } else {\n                    errors.push({\n                        item: result.value.item,\n                        error: result.value.error || new Error(\"Unknown error\")\n                    });\n                }\n            } else {\n                throw result.reason;\n            }\n        });\n    }\n    return {\n        results,\n        errors\n    };\n}\n// Êù°‰ª∂ÈáçËØïÂáΩÊï∞\nasync function withConditionalRetry(fn, condition, options = {}) {\n    return withRetry(async ()=>{\n        const result = await fn();\n        if (!condition(result)) {\n            throw new Error(\"Condition not met\");\n        }\n        return result;\n    }, options);\n}\n// Â∑•ÂÖ∑ÂáΩÊï∞\nfunction sleep(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\n// ÈáçËØïË£ÖÈ•∞Âô®ÔºàÁî®‰∫éÁ±ªÊñπÊ≥ïÔºâ\nfunction Retryable(options = {}) {\n    return function(target, propertyName, descriptor) {\n        const method = descriptor.value;\n        descriptor.value = async function(...args) {\n            return withRetry(()=>method.apply(this, args), options);\n        };\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvdXRpbHMvcmV0cnkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQWNBLE9BQU87QUFDQSxTQUFTQSxpQkFBaUJDLEtBQVU7SUFDekMsSUFBSSxDQUFDQSxPQUFPLE9BQU87SUFFbkIsTUFBTUMsc0JBQXNCO1FBQzFCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBRUQsTUFBTUMseUJBQXlCO1FBQzdCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBRUQsU0FBUztJQUNULElBQUlGLE1BQU1HLElBQUksSUFBSUYsb0JBQW9CRyxRQUFRLENBQUNKLE1BQU1HLElBQUksR0FBRztRQUMxRCxPQUFPO0lBQ1Q7SUFFQSxTQUFTO0lBQ1QsSUFBSUgsTUFBTUssT0FBTyxFQUFFO1FBQ2pCLE1BQU1DLGVBQWVOLE1BQU1LLE9BQU8sQ0FBQ0UsV0FBVztRQUM5QyxPQUFPTCx1QkFBdUJNLElBQUksQ0FBQ0MsQ0FBQUEsTUFBT0gsYUFBYUYsUUFBUSxDQUFDSztJQUNsRTtJQUVBLGNBQWM7SUFDZCxJQUFJVCxNQUFNVSxNQUFNLEVBQUU7UUFDaEIsT0FBTztZQUFDO1lBQUs7WUFBSztZQUFLO1lBQUs7WUFBSztTQUFJLENBQUNOLFFBQVEsQ0FBQ0osTUFBTVUsTUFBTTtJQUM3RDtJQUVBLE9BQU87QUFDVDtBQUVBLFNBQVM7QUFDRixTQUFTQyxtQkFDZEMsT0FBZSxFQUNmQyxZQUFvQixJQUFJLEVBQ3hCQyxXQUFtQixLQUFLLEVBQ3hCQyxvQkFBNEIsQ0FBQztJQUU3QixNQUFNQyxRQUFRQyxLQUFLQyxHQUFHLENBQ3BCTCxZQUFZSSxLQUFLRSxHQUFHLENBQUNKLG1CQUFtQkgsVUFBVSxJQUNsREU7SUFHRixnQkFBZ0I7SUFDaEIsTUFBTU0sU0FBU0osUUFBUSxNQUFNQyxLQUFLSSxNQUFNO0lBRXhDLE9BQU9MLFFBQVFJO0FBQ2pCO0FBRUEsU0FBUztBQUNGLGVBQWVFLFVBQ3BCQyxFQUFvQixFQUNwQkMsVUFBd0IsQ0FBQyxDQUFDO0lBRTFCLE1BQU0sRUFDSkMsYUFBYSxDQUFDLEVBQ2RaLFlBQVksSUFBSSxFQUNoQkMsV0FBVyxLQUFLLEVBQ2hCQyxvQkFBb0IsQ0FBQyxFQUNyQkssU0FBUyxJQUFJLEVBQ2QsR0FBR0k7SUFFSixNQUFNRSxZQUFZQyxLQUFLQyxHQUFHO0lBQzFCLElBQUlDLFlBQTBCO0lBRTlCLElBQUssSUFBSWpCLFVBQVUsR0FBR0EsV0FBV2EsYUFBYSxHQUFHYixVQUFXO1FBQzFELElBQUk7WUFDRixNQUFNa0IsU0FBUyxNQUFNUDtZQUNyQixNQUFNUSxZQUFZSixLQUFLQyxHQUFHLEtBQUtGO1lBRS9CLE9BQU87Z0JBQ0xJO2dCQUNBRSxVQUFVcEI7Z0JBQ1ZtQjtZQUNGO1FBQ0YsRUFBRSxPQUFPL0IsT0FBTztZQUNkNkIsWUFBWTdCO1lBRVosZ0JBQWdCO1lBQ2hCLElBQUksQ0FBQ0QsaUJBQWlCQyxRQUFRO2dCQUM1QixNQUFNQTtZQUNSO1lBRUEsb0JBQW9CO1lBQ3BCLElBQUlZLFVBQVVhLFlBQVk7Z0JBQ3hCO1lBQ0Y7WUFFQSxTQUFTO1lBQ1QsTUFBTVQsUUFBUUksU0FDVlQsbUJBQW1CQyxTQUFTQyxXQUFXQyxVQUFVQyxxQkFDakRGLFlBQVlJLEtBQUtFLEdBQUcsQ0FBQ0osbUJBQW1CSCxVQUFVO1lBRXREcUIsUUFBUUMsR0FBRyxDQUFDLENBQUMsWUFBWSxFQUFFdEIsUUFBUSxxQkFBcUIsRUFBRUksTUFBTSxLQUFLLENBQUM7WUFDdEUsTUFBTW1CLE1BQU1uQjtRQUNkO0lBQ0Y7SUFFQSxNQUFNZSxZQUFZSixLQUFLQyxHQUFHLEtBQUtGO0lBQy9CLE1BQU0sSUFBSVUsTUFDUixDQUFDLHVCQUF1QixFQUFFWCxhQUFhLEVBQUUsV0FBVyxFQUFFTSxVQUFVLEtBQUssRUFBRUYsV0FBV3hCLFFBQVEsQ0FBQztBQUUvRjtBQUVBLFdBQVc7QUFDSixlQUFlZ0Msb0JBQ3BCZCxFQUFvQixFQUNwQmUsVUFBa0IsS0FBSyxFQUN2QkMsZUFBNkIsQ0FBQyxDQUFDO0lBRS9CLE9BQU9qQixVQUNMLElBQU1rQixRQUFRQyxJQUFJLENBQUM7WUFDakJsQjtZQUNBLElBQUlpQixRQUFlLENBQUNFLEdBQUdDLFNBQ3JCQyxXQUFXLElBQU1ELE9BQU8sSUFBSVAsTUFBTSx1QkFBdUJFO1NBRTVELEdBQ0RDO0FBRUo7QUFFQSxTQUFTO0FBQ0YsZUFBZU0sZUFDcEJDLEtBQVUsRUFDVkMsU0FBb0MsRUFDcEN2QixVQUdJLENBQUMsQ0FBQztJQUVOLE1BQU0sRUFDSndCLGNBQWMsQ0FBQyxFQUNmQyxjQUFjLEtBQUssRUFDbkIsR0FBR1YsY0FDSixHQUFHZjtJQUVKLE1BQU0wQixVQUFpQixFQUFFO0lBQ3pCLE1BQU1DLFNBQTJDLEVBQUU7SUFFbkQsT0FBTztJQUNQLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTixNQUFNTyxNQUFNLEVBQUVELEtBQUtKLFlBQWE7UUFDbEQsTUFBTU0sUUFBUVIsTUFBTVMsS0FBSyxDQUFDSCxHQUFHQSxJQUFJSjtRQUVqQyxNQUFNUSxnQkFBZ0JGLE1BQU1HLEdBQUcsQ0FBQyxPQUFPQztZQUNyQyxJQUFJO2dCQUNGLE1BQU01QixTQUFTLE1BQU1SLFVBQVUsSUFBTXlCLFVBQVVXLE9BQU9uQjtnQkFDdEQsT0FBTztvQkFBRW9CLFNBQVM7b0JBQU1EO29CQUFNNUIsUUFBUUEsT0FBT0EsTUFBTTtnQkFBQztZQUN0RCxFQUFFLE9BQU85QixPQUFPO2dCQUNkLElBQUlpRCxhQUFhO29CQUNmLE1BQU1qRDtnQkFDUjtnQkFDQSxPQUFPO29CQUFFMkQsU0FBUztvQkFBT0Q7b0JBQU0xRCxPQUFPQTtnQkFBZTtZQUN2RDtRQUNGO1FBRUEsTUFBTTRELGVBQWUsTUFBTXBCLFFBQVFxQixVQUFVLENBQUNMO1FBRTlDSSxhQUFhRSxPQUFPLENBQUMsQ0FBQ2hDO1lBQ3BCLElBQUlBLE9BQU9wQixNQUFNLEtBQUssYUFBYTtnQkFDakMsSUFBSW9CLE9BQU9pQyxLQUFLLENBQUNKLE9BQU8sRUFBRTtvQkFDeEJULFFBQVFjLElBQUksQ0FBQ2xDLE9BQU9pQyxLQUFLLENBQUNqQyxNQUFNO2dCQUNsQyxPQUFPO29CQUNMcUIsT0FBT2EsSUFBSSxDQUFDO3dCQUFFTixNQUFNNUIsT0FBT2lDLEtBQUssQ0FBQ0wsSUFBSTt3QkFBRTFELE9BQU84QixPQUFPaUMsS0FBSyxDQUFDL0QsS0FBSyxJQUFJLElBQUlvQyxNQUFNO29CQUFpQjtnQkFDakc7WUFDRixPQUFPO2dCQUNMLE1BQU1OLE9BQU9tQyxNQUFNO1lBQ3JCO1FBQ0Y7SUFDRjtJQUVBLE9BQU87UUFBRWY7UUFBU0M7SUFBTztBQUMzQjtBQUVBLFNBQVM7QUFDRixlQUFlZSxxQkFDcEIzQyxFQUFvQixFQUNwQjRDLFNBQWlDLEVBQ2pDM0MsVUFBd0IsQ0FBQyxDQUFDO0lBRTFCLE9BQU9GLFVBQVU7UUFDZixNQUFNUSxTQUFTLE1BQU1QO1FBQ3JCLElBQUksQ0FBQzRDLFVBQVVyQyxTQUFTO1lBQ3RCLE1BQU0sSUFBSU0sTUFBTTtRQUNsQjtRQUNBLE9BQU9OO0lBQ1QsR0FBR047QUFDTDtBQUVBLE9BQU87QUFDUCxTQUFTVyxNQUFNaUMsRUFBVTtJQUN2QixPQUFPLElBQUk1QixRQUFRNkIsQ0FBQUEsVUFBV3pCLFdBQVd5QixTQUFTRDtBQUNwRDtBQUVBLGVBQWU7QUFDUixTQUFTRSxVQUFVOUMsVUFBd0IsQ0FBQyxDQUFDO0lBQ2xELE9BQU8sU0FBVStDLE1BQVcsRUFBRUMsWUFBb0IsRUFBRUMsVUFBOEI7UUFDaEYsTUFBTUMsU0FBU0QsV0FBV1YsS0FBSztRQUUvQlUsV0FBV1YsS0FBSyxHQUFHLGVBQWdCLEdBQUdZLElBQVc7WUFDL0MsT0FBT3JELFVBQVUsSUFBTW9ELE9BQU9FLEtBQUssQ0FBQyxJQUFJLEVBQUVELE9BQU9uRDtRQUNuRDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbGluay8uL2xpYi91dGlscy9yZXRyeS50cz9lNDA5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgUmV0cnlPcHRpb25zIHtcbiAgbWF4UmV0cmllcz86IG51bWJlcjtcbiAgYmFzZURlbGF5PzogbnVtYmVyO1xuICBtYXhEZWxheT86IG51bWJlcjtcbiAgYmFja29mZk11bHRpcGxpZXI/OiBudW1iZXI7XG4gIGppdHRlcj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmV0cnlSZXN1bHQ8VD4ge1xuICByZXN1bHQ6IFQ7XG4gIGF0dGVtcHRzOiBudW1iZXI7XG4gIHRvdGFsVGltZTogbnVtYmVyO1xufVxuXG4vLyDplJnor6/liIbnsbtcbmV4cG9ydCBmdW5jdGlvbiBpc1RyYW5zaWVudEVycm9yKGVycm9yOiBhbnkpOiBib29sZWFuIHtcbiAgaWYgKCFlcnJvcikgcmV0dXJuIGZhbHNlO1xuXG4gIGNvbnN0IHRyYW5zaWVudEVycm9yQ29kZXMgPSBbXG4gICAgJ1BHUlNUMzAxJywgLy8gQ29ubmVjdGlvbiB0aW1lb3V0XG4gICAgJ1BHUlNUMzAyJywgLy8gQ29ubmVjdGlvbiByZWZ1c2VkXG4gICAgJ1BHUlNUMzAzJywgLy8gTmV0d29yayBlcnJvclxuICAgICdQR1JTVDMwNCcsIC8vIFNlcnZlciBlcnJvclxuICAgICdQR1JTVDMwNScsIC8vIFNlcnZpY2UgdW5hdmFpbGFibGVcbiAgICAnRUNPTk5SRVNFVCcsXG4gICAgJ0VDT05OUkVGVVNFRCcsXG4gICAgJ0VUSU1FRE9VVCcsXG4gICAgJ0VOT1RGT1VORCdcbiAgXTtcblxuICBjb25zdCB0cmFuc2llbnRFcnJvck1lc3NhZ2VzID0gW1xuICAgICd0aW1lb3V0JyxcbiAgICAnY29ubmVjdGlvbicsXG4gICAgJ25ldHdvcmsnLFxuICAgICd0ZW1wb3JhcnknLFxuICAgICdyZXRyeScsXG4gICAgJ3JhdGUgbGltaXQnLFxuICAgICd0b28gbWFueSByZXF1ZXN0cycsXG4gICAgJ3NlcnZpY2UgdW5hdmFpbGFibGUnLFxuICAgICdpbnRlcm5hbCBzZXJ2ZXIgZXJyb3InXG4gIF07XG5cbiAgLy8g5qOA5p+l6ZSZ6K+v5Luj56CBXG4gIGlmIChlcnJvci5jb2RlICYmIHRyYW5zaWVudEVycm9yQ29kZXMuaW5jbHVkZXMoZXJyb3IuY29kZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIOajgOafpemUmeivr+a2iOaBr1xuICBpZiAoZXJyb3IubWVzc2FnZSkge1xuICAgIGNvbnN0IGxvd2VyTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gdHJhbnNpZW50RXJyb3JNZXNzYWdlcy5zb21lKG1zZyA9PiBsb3dlck1lc3NhZ2UuaW5jbHVkZXMobXNnKSk7XG4gIH1cblxuICAvLyDmo4Dmn6UgSFRUUCDnirbmgIHnoIFcbiAgaWYgKGVycm9yLnN0YXR1cykge1xuICAgIHJldHVybiBbNDA4LCA0MjksIDUwMCwgNTAyLCA1MDMsIDUwNF0uaW5jbHVkZXMoZXJyb3Iuc3RhdHVzKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8g5oyH5pWw6YCA6YG/566X5rOVXG5leHBvcnQgZnVuY3Rpb24gZXhwb25lbnRpYWxCYWNrb2ZmKFxuICBhdHRlbXB0OiBudW1iZXIsIFxuICBiYXNlRGVsYXk6IG51bWJlciA9IDEwMDAsIFxuICBtYXhEZWxheTogbnVtYmVyID0gMzAwMDAsXG4gIGJhY2tvZmZNdWx0aXBsaWVyOiBudW1iZXIgPSAyXG4pOiBudW1iZXIge1xuICBjb25zdCBkZWxheSA9IE1hdGgubWluKFxuICAgIGJhc2VEZWxheSAqIE1hdGgucG93KGJhY2tvZmZNdWx0aXBsaWVyLCBhdHRlbXB0IC0gMSksXG4gICAgbWF4RGVsYXlcbiAgKTtcbiAgXG4gIC8vIOa3u+WKoOmaj+acuuaKluWKqOS7pemBv+WFjeaDiue+pOaViOW6lFxuICBjb25zdCBqaXR0ZXIgPSBkZWxheSAqIDAuMSAqIE1hdGgucmFuZG9tKCk7XG4gIFxuICByZXR1cm4gZGVsYXkgKyBqaXR0ZXI7XG59XG5cbi8vIOaZuuiDvemHjeivleWHveaVsFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdpdGhSZXRyeTxUPihcbiAgZm46ICgpID0+IFByb21pc2U8VD4sXG4gIG9wdGlvbnM6IFJldHJ5T3B0aW9ucyA9IHt9XG4pOiBQcm9taXNlPFJldHJ5UmVzdWx0PFQ+PiB7XG4gIGNvbnN0IHtcbiAgICBtYXhSZXRyaWVzID0gMyxcbiAgICBiYXNlRGVsYXkgPSAxMDAwLFxuICAgIG1heERlbGF5ID0gMzAwMDAsXG4gICAgYmFja29mZk11bHRpcGxpZXIgPSAyLFxuICAgIGppdHRlciA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgbGV0IGxhc3RFcnJvcjogRXJyb3IgfCBudWxsID0gbnVsbDtcblxuICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBtYXhSZXRyaWVzICsgMTsgYXR0ZW1wdCsrKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQsXG4gICAgICAgIGF0dGVtcHRzOiBhdHRlbXB0LFxuICAgICAgICB0b3RhbFRpbWVcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxhc3RFcnJvciA9IGVycm9yIGFzIEVycm9yO1xuICAgICAgXG4gICAgICAvLyDlpoLmnpzkuI3mmK/kuLTml7bplJnor6/vvIznm7TmjqXmipvlh7pcbiAgICAgIGlmICghaXNUcmFuc2llbnRFcnJvcihlcnJvcikpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIOWmguaenOW3sue7j+i+vuWIsOacgOWkp+mHjeivleasoeaVsO+8jOaKm+WHuumUmeivr1xuICAgICAgaWYgKGF0dGVtcHQgPiBtYXhSZXRyaWVzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyDorqHnrpflu7bov5/ml7bpl7RcbiAgICAgIGNvbnN0IGRlbGF5ID0gaml0dGVyIFxuICAgICAgICA/IGV4cG9uZW50aWFsQmFja29mZihhdHRlbXB0LCBiYXNlRGVsYXksIG1heERlbGF5LCBiYWNrb2ZmTXVsdGlwbGllcilcbiAgICAgICAgOiBiYXNlRGVsYXkgKiBNYXRoLnBvdyhiYWNrb2ZmTXVsdGlwbGllciwgYXR0ZW1wdCAtIDEpO1xuXG4gICAgICBjb25zb2xlLmxvZyhg4pqg77iPICBBdHRlbXB0ICR7YXR0ZW1wdH0gZmFpbGVkLCByZXRyeWluZyBpbiAke2RlbGF5fW1zLi4uYCk7XG4gICAgICBhd2FpdCBzbGVlcChkZWxheSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdG90YWxUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBPcGVyYXRpb24gZmFpbGVkIGFmdGVyICR7bWF4UmV0cmllcyArIDF9IGF0dGVtcHRzICgke3RvdGFsVGltZX1tcyk6ICR7bGFzdEVycm9yPy5tZXNzYWdlfWBcbiAgKTtcbn1cblxuLy8g5bim6LaF5pe255qE6YeN6K+V5Ye95pWwXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2l0aFJldHJ5QW5kVGltZW91dDxUPihcbiAgZm46ICgpID0+IFByb21pc2U8VD4sXG4gIHRpbWVvdXQ6IG51bWJlciA9IDMwMDAwLFxuICByZXRyeU9wdGlvbnM6IFJldHJ5T3B0aW9ucyA9IHt9XG4pOiBQcm9taXNlPFJldHJ5UmVzdWx0PFQ+PiB7XG4gIHJldHVybiB3aXRoUmV0cnkoXG4gICAgKCkgPT4gUHJvbWlzZS5yYWNlKFtcbiAgICAgIGZuKCksXG4gICAgICBuZXcgUHJvbWlzZTxuZXZlcj4oKF8sIHJlamVjdCkgPT4gXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignT3BlcmF0aW9uIHRpbWVvdXQnKSksIHRpbWVvdXQpXG4gICAgICApXG4gICAgXSksXG4gICAgcmV0cnlPcHRpb25zXG4gICk7XG59XG5cbi8vIOaJuemHj+mHjeivleWHveaVsFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdpdGhCYXRjaFJldHJ5PFQ+KFxuICBpdGVtczogVFtdLFxuICBwcm9jZXNzb3I6IChpdGVtOiBUKSA9PiBQcm9taXNlPGFueT4sXG4gIG9wdGlvbnM6IFJldHJ5T3B0aW9ucyAmIHsgXG4gICAgY29uY3VycmVuY3k/OiBudW1iZXI7XG4gICAgc3RvcE9uRXJyb3I/OiBib29sZWFuO1xuICB9ID0ge31cbik6IFByb21pc2U8eyByZXN1bHRzOiBhbnlbXTsgZXJyb3JzOiBBcnJheTx7IGl0ZW06IFQ7IGVycm9yOiBFcnJvciB9PiB9PiB7XG4gIGNvbnN0IHtcbiAgICBjb25jdXJyZW5jeSA9IDUsXG4gICAgc3RvcE9uRXJyb3IgPSBmYWxzZSxcbiAgICAuLi5yZXRyeU9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgcmVzdWx0czogYW55W10gPSBbXTtcbiAgY29uc3QgZXJyb3JzOiBBcnJheTx7IGl0ZW06IFQ7IGVycm9yOiBFcnJvciB9PiA9IFtdO1xuXG4gIC8vIOWIhuaJueWkhOeQhlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSBjb25jdXJyZW5jeSkge1xuICAgIGNvbnN0IGJhdGNoID0gaXRlbXMuc2xpY2UoaSwgaSArIGNvbmN1cnJlbmN5KTtcbiAgICBcbiAgICBjb25zdCBiYXRjaFByb21pc2VzID0gYmF0Y2gubWFwKGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aXRoUmV0cnkoKCkgPT4gcHJvY2Vzc29yKGl0ZW0pLCByZXRyeU9wdGlvbnMpO1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBpdGVtLCByZXN1bHQ6IHJlc3VsdC5yZXN1bHQgfTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChzdG9wT25FcnJvcikge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBpdGVtLCBlcnJvcjogZXJyb3IgYXMgRXJyb3IgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGJhdGNoUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChiYXRjaFByb21pc2VzKTtcbiAgICBcbiAgICBiYXRjaFJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgaWYgKHJlc3VsdC52YWx1ZS5zdWNjZXNzKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdC52YWx1ZS5yZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9ycy5wdXNoKHsgaXRlbTogcmVzdWx0LnZhbHVlLml0ZW0sIGVycm9yOiByZXN1bHQudmFsdWUuZXJyb3IgfHwgbmV3IEVycm9yKCdVbmtub3duIGVycm9yJykgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlc3VsdC5yZWFzb247XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4geyByZXN1bHRzLCBlcnJvcnMgfTtcbn1cblxuLy8g5p2h5Lu26YeN6K+V5Ye95pWwXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2l0aENvbmRpdGlvbmFsUmV0cnk8VD4oXG4gIGZuOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBjb25kaXRpb246IChyZXN1bHQ6IFQpID0+IGJvb2xlYW4sXG4gIG9wdGlvbnM6IFJldHJ5T3B0aW9ucyA9IHt9XG4pOiBQcm9taXNlPFJldHJ5UmVzdWx0PFQ+PiB7XG4gIHJldHVybiB3aXRoUmV0cnkoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKCk7XG4gICAgaWYgKCFjb25kaXRpb24ocmVzdWx0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25kaXRpb24gbm90IG1ldCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBvcHRpb25zKTtcbn1cblxuLy8g5bel5YW35Ye95pWwXG5mdW5jdGlvbiBzbGVlcChtczogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cblxuLy8g6YeN6K+V6KOF6aWw5Zmo77yI55So5LqO57G75pa55rOV77yJXG5leHBvcnQgZnVuY3Rpb24gUmV0cnlhYmxlKG9wdGlvbnM6IFJldHJ5T3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0OiBhbnksIHByb3BlcnR5TmFtZTogc3RyaW5nLCBkZXNjcmlwdG9yOiBQcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgICBjb25zdCBtZXRob2QgPSBkZXNjcmlwdG9yLnZhbHVlO1xuXG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzOiBhbnlbXSkge1xuICAgICAgcmV0dXJuIHdpdGhSZXRyeSgoKSA9PiBtZXRob2QuYXBwbHkodGhpcywgYXJncyksIG9wdGlvbnMpO1xuICAgIH07XG4gIH07XG59ICJdLCJuYW1lcyI6WyJpc1RyYW5zaWVudEVycm9yIiwiZXJyb3IiLCJ0cmFuc2llbnRFcnJvckNvZGVzIiwidHJhbnNpZW50RXJyb3JNZXNzYWdlcyIsImNvZGUiLCJpbmNsdWRlcyIsIm1lc3NhZ2UiLCJsb3dlck1lc3NhZ2UiLCJ0b0xvd2VyQ2FzZSIsInNvbWUiLCJtc2ciLCJzdGF0dXMiLCJleHBvbmVudGlhbEJhY2tvZmYiLCJhdHRlbXB0IiwiYmFzZURlbGF5IiwibWF4RGVsYXkiLCJiYWNrb2ZmTXVsdGlwbGllciIsImRlbGF5IiwiTWF0aCIsIm1pbiIsInBvdyIsImppdHRlciIsInJhbmRvbSIsIndpdGhSZXRyeSIsImZuIiwib3B0aW9ucyIsIm1heFJldHJpZXMiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwibGFzdEVycm9yIiwicmVzdWx0IiwidG90YWxUaW1lIiwiYXR0ZW1wdHMiLCJjb25zb2xlIiwibG9nIiwic2xlZXAiLCJFcnJvciIsIndpdGhSZXRyeUFuZFRpbWVvdXQiLCJ0aW1lb3V0IiwicmV0cnlPcHRpb25zIiwiUHJvbWlzZSIsInJhY2UiLCJfIiwicmVqZWN0Iiwic2V0VGltZW91dCIsIndpdGhCYXRjaFJldHJ5IiwiaXRlbXMiLCJwcm9jZXNzb3IiLCJjb25jdXJyZW5jeSIsInN0b3BPbkVycm9yIiwicmVzdWx0cyIsImVycm9ycyIsImkiLCJsZW5ndGgiLCJiYXRjaCIsInNsaWNlIiwiYmF0Y2hQcm9taXNlcyIsIm1hcCIsIml0ZW0iLCJzdWNjZXNzIiwiYmF0Y2hSZXN1bHRzIiwiYWxsU2V0dGxlZCIsImZvckVhY2giLCJ2YWx1ZSIsInB1c2giLCJyZWFzb24iLCJ3aXRoQ29uZGl0aW9uYWxSZXRyeSIsImNvbmRpdGlvbiIsIm1zIiwicmVzb2x2ZSIsIlJldHJ5YWJsZSIsInRhcmdldCIsInByb3BlcnR5TmFtZSIsImRlc2NyaXB0b3IiLCJtZXRob2QiLCJhcmdzIiwiYXBwbHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/utils/retry.ts\n");

/***/ })

};
;